aPart 1 기본 무대 및 UI 세팅
I. Edit -> Grid and Snap Setting을 이용하여 편하게 맵 만들기 (마우스를 통해 오브젝트를 한번 움직일 때마다 얼마나 움직일지를 설정할 수 있음)
II. UI 에서 Anchor Position을 설정할 때는 부모는 상단, 하단 처럼 전체적인 틀을 잡고 자식을 구석과 같이 디테일하게 설정하면 좋음 가운데에 있는 애들은 굳이 설정 안해도 해상도 맞춰짐 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 1 크로스헤어 구현

1. [SerializeField] 는 private의 보호 수준은 유지하면서 인스펙터 창에 변수의 값을 보이게 함(할당도 가능)

2. 크로스헤어가 마우스 따라가게하기
I. 크로스 헤어의 포지션 값 
크로스헤어 UI는 Canvas의 자식 오브젝트이므로 원하는 좌표 값을 얻거나 할당하기 위해서는 부모 객처를 기준으로 상대적으로 얼마나 떨어져 있는지를 나타내는 localposition을 사용해야함

이때 Input.mouseposition 값을 크로스헤어의 포지션값에 그대로 적용했을 때 Input.mouseposition값은 화면 왼쪽 아래를 기준으로 0, 0을 가지기 때문에 마우스를 왼쪽 아래 구석에 가져가면 크로스헤어가 가운대로 오는 기적을 감상할 수 있기 때문에 x, y축에 스크린의 넓이와 높이의 반만큼 빼줘야함 그러면 왼쪽 아래 구석에 마우스를 놀 때 크로스 헤어의 포지션 값에 0, 0에서 화면 크기의 넓이와 높이의 반만큼 뺸 값이 대입되기 때문에 마우스와 똑같이 위치함

II. Screen : 디스플레이 정보에 접근하는데 사용하며 지원되는 해상도 목록을 가져오거나 변환하는데 사용됨
Screen.width : 해상도를 기준으로 화면의 넓이를 가져오며 단위는 픽셀을 사용(height는 높이) 

III. 주의사항
스크린의 크기는 해상도를 기준으로 가져오고 크로스헤어는 UI이므로 Canvas Sclaer의 Reference Resolution 값을 기준으로 위치하기 때문에 Reference Resolution의 값과 해상도 값을 일치시켜야함
만약 해상도를 Reference Resolution 값보다 크게 하면 스크린 값이 Canvas보다 크게 설정되어 크로스헤어의 포지션이 마우스 위치와 달라짐

Screen 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Screen.html
Input.mousePosition 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Input-mousePosition.html

3. 크로스헤어가 화면 밖으로 나가지 않게 하기
필요성 : Input.mouseposition는 마우스 포인터가 화면 밖에 있어도 위치를 보고하기 때문에 크로스헤어가 화면밖으로 나가 보이지 않을 수 있어 크로스헤어의 위치에 제한을 두어 화면 밖으로 나가지 않게 함

I. Mathf.Clamp()함수 
Mathf.Clamp(float value, float min, float max) : 기본적으로 value의 값을 반환하지만 value가 min보다 작으면 min을 max보다 크면 max값을 반환함 즉 기본적으로 vlaue를 반환하되 원하는 범위만큼 제한을 둔 값을 반환할 수 있음 value의 값에는 영향을 주지 않고 오직 반환값만 제한됨 

II. 마우스 포지션 값과 스크린 크기 값에 기반해 먼저 크로스헤어의 x, y 변숫값을 구한 후 그 변수에 이 함수를 통해 스크린의 크기만큼 제한한 값을 대입해 크로스헤어가 화면 밖으로 나가는 것을 방지함 

private float cursorMargin = 30; // 마진을 다 크로스헤어의 모든 부분이 화면에 보이게 하기 위한 여백값
// 크로스 헤어의 좌표값 구함
float corsshair_X = Input.mousePosition.x - Screen.width / 2;
float corsshair_Y = Input.mousePosition.y - Screen.height / 2;

// corsshair가 화면 밖으로 나가는거 방지하기 위해 스크린 크기만큼 제한한 값을 다시 할당
corsshair_X = Mathf.Clamp(corsshair_X, -Screen.width / 2 + cursorMargin, Screen.width / 2 - cursorMargin);
corsshair_Y = Mathf.Clamp(corsshair_Y, -Screen.height / 2 + cursorMargin, Screen.height / 2 - cursorMargin);
tf_Corsshair.localPosition = new Vector2(corsshair_X, corsshair_Y);

4. 강의 내용 외의 시도
I. RectTranform을 사용할 경우 크로스헤어가 마우스를 그래도 따라가지만 여전히 좌측 하단이 0, 0이기 때문에 Screen의 크기를 이용해 크로스헤어의 범위에 제한을 두는 데에 문제가 생김
RectTransform을 사용하면 마우스를 그대로 따라가는 이유는 RectTransform도 좌측 하단이 0, 0 이디 때문임

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 2 뷰 회전 (크로스 헤어)

1. 크로스헤어가 끝부분에 있으면 그쪽 방향으로 회전하기
I. Part 2 - 1에서 구현한 크로스 헤어의 위치값이 스크린의 절반보다 크거나 작으면 작동하는  조건문 제작
if( corsshair_X > half_ScreenWidth - 80 || corsshair_X > -half_ScreenWidth + 80 )

II. 삼항 연산자를 통해 x좌표의 부호에 따라 회전값 변수에 회전 속도 변수를 더하거나 뺌
currentCameraAngle_Y += ( corsshair_X > 0 ) ? rotateSpeed : -rotateSpeed; 

III. 연산이 이뤄진 회전값 변수에 Mathf.Clamp() 함수를 이용하여 회전값에 제한을 둔 후 카메라 회전값에 대입함
currentCameraAngle_Y = Mathf.Clamp(currentCameraAngle_Y, -look_X_Limit, look_X_Limit);
같은 방법으로 currentCameraAngle_X를 구한 후 대입( 이때 x축 회전값의 방향은 더하면 내려가고 빼면 올라가기 때문에 삼항연산자 부호를 반대로 해야함)
th_Camera.rotation = Quaternion.Euler(new Vector3(currentCameraAngle_X, currentCameraAngle_Y, 0));

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 3 뷰 이동 및 회전 (방향키)

1. 키보드를 이용한 회전 구현
I. 수평 수직 키 입력을 받는 Input.GetAxisRaw값을 이용해 Part 2 - 2의 방법을 그대로 적용하여 회전 구현 (GetAxis값은 입력에 따라 음수 양수 값이 나오기 때문에 삼항연사자는 필요 없음) 
이때 Input.GetAxisRaw는 -1, 0, 1의 값 3가지만 반환하며 Input.GetAxis는 -1, 1까지의 값을 반환한다 즉 부드러운 이동은 Input.GetAxis를 키보드와 같이 입력 시 바로 반응해야 하는 경우에는 Input.GetAxisRaw를 사용한다.
float getKey_X = Input.GetAxisRaw("Horizontal");
if (getKey_X != 0) currentCameraAngle_Y += getKey_X * playerRotateSpeed;


2. 플레이어 이동 구현
I. 회전할 때 회전 방향과 같은 방향으로 이동 나는 강의에서랑 조금 다르게 float 파라미터를 가진 함수를 만들어 인자값의 부호에 따라 속도 변수만큼 움직이는 함수를 만든 후 회전 조건문 안에 넣음
void MoveX(float moveDirection)
{
    float move_X = (moveDirection > 0) ? playerMoveSpeed : -playerMoveSpeed;
    tf_Camera.localPosition += Vector3.right * move_X;
}

II. 실제 함수 사용
if(corsshair_X > half_ScreenWidth - 80 || corsshair_X < -half_ScreenWidth + 80)
{
    currentCameraAngle_Y += (corsshair_X > 0) ? playerRotateSpeed : -playerRotateSpeed;
    MoveX(corsshair_X); // 회전의 기준이 되는 corsshair_X를 argument값으로 넣음 (키보드는 GetAxisRaw값)
}
Y축 이동은 방향만 바꾼 후 똑같이 함수 만들고 똑같이 적용함


3. 플레이어 이동 위치 제한 구현
카메라 위치가 지정한 변숫값보다 크거나 작으면 그 포지션 값을 변수값으로 고정
if(tf_Camera.localPosition.x > move_X_Limit || tf_Camera.localPosition.x < -move_X_Limit)
{
	tf_Camera.localPosition = new Vector3( (tf_Camera.localPosition.x > 0) ? move_X_Limit : -move_X_Limit ,  tf_Camera.localPosition.y, tf_Camera.localPosition.z);
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 4 디테일 (Spin 및 추가 UI)

1. 해당 방향으로 회전을 못할 때 회전을 못한다는 것을 알려주는 UI 제작
I. UI 4개 만들고 현재 회전값이 지정한 최대 방향값보다 높으면 해당 방향의 금지 모양 UI의 SetActive(true)하고 아니면 false하기

2. 크로스헤어의 노란색 부분이 아톰 홈페이지마냥 계속 빙글빙글 돌아가게 만들기 (Spin Script)
I. transform.Rotate(Vector3 eulers) : argument값의 Vector3만큼 회전시키는 함수 Translate()랑 비슷함
II. Time.deltaTime : 이전 프레임과 현재프레임의 시간차이를 반환함 1초에 60프레임이라면 1 / 60 반환 Update문에서 속도 변수에 곱하면 1초에 원하는 값만큼 움직여서 따로 복잡한 연산이 필요없음
transform.Rotate(spinDir * spinSpeed * Time.deltaTime);

3. 상수를 변수로 바꾸기
I. const와 readonly
공통점 : 둘 다 변수를 상수로 선언해 재할당이 불가능하다

차이점 : const는 컴파일 타입의 상수이고 readonly는 런타임 타입의 상수이다. 즉 const는 컴파일 시 변숫값을 가져오고 readonly는 exe, dll 등의 파일 실행 시 값을 가져온다 이 때문에 const를 사용하면 조금이라도 프로그램에 더 빠르게 접근 가능하지만 상숫값을 변경할 때 그 값과 관련된 프로젝트를 모두 다시 컴파일해야하는 단점이 있다 때문에 상숫값 변경 시 재 컴파일을 하지 않고 사용하는 생성자 단계에서 변수에 값을 할당하는 readonly가 더 각광받고 있는 추세이다.

관련 내용 블로그 : https://holjjack.tistory.com/95

II. 카메라 상수 변수로 바꾸기
카메라의 Y포지션이 0이 아닌 1이기 때문에 카메라 포지션 제한값을 둘 때 1에 지정한 위치값을 더하는 형식으로 카메라 위치를 제한했는데 이를 게임 시작 시 현재 카메라 Y값을 변수에 대입해 1대신에 사용
이럴 경우 후에 카메라의 위치가 바뀌어도 카메라의 위치값을 변수에 대입하기 때문에 코드를 건드리지 않아도 됨

originPos_CameraY = tf_Camera.localPosition.y;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 1 상호작용

1. 상호작용 가능한 객체 위에 마우스 울리면 UI 변하기
I. 상호작용 전용 여러 이미지를 겹치게 해서 UI Interactive_Corsshair 제작하기

2. 카메라에서 Ray발사하기 (IntreactionCortroller Script)
I. 게임 카메라 상에서의 마우스 포지션을 게임에서의 월드 포지션으로 바꾼 후 그 값을 이용하여 Ray를 쏴야 함
이를 구현하기 위해 Camera 클래스에 있는 함수인 SceenPointToRay()에 마우스 포지션 값(카메라가 보고있는 스크린의 점)을 넣어 ray를 반환함
이때 ray는 발사할 Ray의 시작점과 방향을 둘 다 Vector 값으로 가짐  ex) Origin : (1, 0, 3), Dir : (0.7, 0, 0.3)
if (Physics.Raycast(cam.ScreenPointToRay(mousePosition), out rayHit, 100))

ScreenPointToRay 관련 Unity Manual : https://docs.unity3d.com/kr/current/Manual/CameraRays.html
Physics.Raycast 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Physics.Raycast.html

II. 
ray가 맞은 오브젝트의 태그가 Interaction이면 Interactive_Corsshair를 아니면 Normal_Corsshair를 보여줌

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 2 상호작용 이펙트

1. 상호작용 파티클 이펙트 만들기
I. 목표 : 물음표 모양을 한 스프라이트 이미지를 던지는 형식의 이펙트를 연출할 것이므로 딱 한번만 파티클이 나와야 하고 나오는 파티클을 미리 준비한 스프라이트 이미지로 바꾸어야함

II. Emission의 Rate over Time (시간 경과에 따른 입자 방출 수)를 0으로 하고 Bursts (시작 시 방출하는 파티클)의 Count를 1로 함 그리고 파티클의 모양을 스프라이트로 하기 위해 Texture Sheet Animation의 Mode를 Grid에서 Sprites로 바꾼 후 미리 준비해둔 스프라이트를 넣음 그리고 Render에서 Material을 Default-ParticleSystem으로 설정해야 보라색 버그 입자가 아닌 스프라이트가 정상적으로 나옴

III. 그대로 날아가면 재미가 없기 때문에 회전하면서 날아가도록 Rotation over Lifetime에서 Separate Axes를 체크 후 회전 방향을 설정함

IV. 이펙트가 물체에 닿았을 때 터지는 이펙트 만들기
사이즈를 줄이고 StartSpeed를 빠르게 한 후 Bursts의 Count를 20으로 설정하고 사방으로 퍼지도록 Shape를 shpere로 Radius(입자가 뿜어져 나올 영역의 크기로 0에 가까울 수록 한 점에서 뿜어져 나옴)를 0에 가깝게 설정 후 Size over Lifetime을 이용해 입자가 점점 작아지게 설정하고 입자가 원이 아니라 선처럼 뻗어나가도록하게 하기 위해 Render에서 Render Mode를 Billboard에서 Stretched Billboard로 설정 후 Speed나 Length에 따라 찢어지는 정도를 설정 

2. 파티클 투척하기
I. 상호작용이 가능한 상태에서 좌클릭을 하면 파티클이 실행됨 if(Input.GetMouseButtonDown(0) && interactable)

II. 부드러운 움직임을 위해 Lerp(Vector3 start, Vector3 end, float t) 함수를 이용해 이동 (end - start)/ t 만큼 움직임 0.5f면 1 / 2만큼 움직임
상호작용하려는 물체와 충분히 가까워지면 HitEffect를 Play함

III. 오브젝트의 Pivot를 바꿔서 이펙트를 타겟의 transform.position을 기준으로 발사할 때 이미지의 상반신을 향하게끔 바꿈
pivot 변경하는 방법을 다룬 블로그 : https://mariageunit.blogspot.com/2019/07/unity-1.html

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 3 상호작용 이벤트

1. 상호작용 대화창 만들기
I. 대화내용이 나오는 대화창 UI와 상호작용하는 객체의 이름이 나오는 UI 2개를 만듬

II. 새로운 스크립트인 DialogueManager(싱글톤)를 만들어 상호작용 이펙트가 객체와 충돌한 시점에서 대화 관련 UI가 나오도록 함

III. UIManager(싱글톤) 스크립트를 새로 만들어 대화중에는 화살표와 크로스헤어 UI 숨기기 

IV. DialogueManager에 대화중인지를 나타내는 bool 변수 isTalking을 선언하고 대화 중에는 화면 이동과 상호작용(클릭)을 하지 못하도록 함

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 4 디테일 (Tooltip + 추가 연출)

1. 상호작용 가능한 객체에 크로스헤어를 갖다대면 툴팁과 이펙트 뜨게 하기
I. 툴팁 UI, 인터랙션 UI 각각에 맞는 이미지 넣어서 만들기

II. 새로운 스크립트인 InteractoinType 만든 후 어떤 유형의 상호작용 객체인지 판별하기 위한 변수 및 이름 변수 선언 (골드메탈 쯔꾸르 대화기능 구현할 isNpc같이 script로 타입을 구분)
만든 후 봉란 객체에게 스크립트 부여 후 변수 선언 후 상호작용 가능한 상태에서 툴팁 UI와 객체 이름 뜨게 하기

interactable은 상호작용가능 여부
obj_TargetNameBar.SetActive(interactable);
txt_TargetName.text = (interactable) ? rayHit.transform.GetComponent<InteractionType>().GetName() : "";

III. 상호작용 이펙트
크로스헤어 갖다대면 이펙트 나타나게 하기, 코루틴을 이용해 늘 하던 while을 이용해 투명도 값을 조절하는 연출 이용 이때 기존의 Set_InteractionUI(bool interactable) 함수는 업데이트에서 돌아가기 때문에 코루틴 중복실행으로 그대로 확장이 불가능 그렇기에 isContact 변수를 만들어 중복실행을 막음
if (isContact == interactable) return;  
isContact = interactable;

그리고 새로 안 사실인데 코루틴을 문자열로 이용할때도 인수 하나까지는 커버를 칠 수 있었음 StartCoroutine("Co_AppearInteractionImg", true); 이런 식으로 사용하면 인수 하나있는 코루틴까지는 편하게 
정지가 가능 여기서도 중복 실행 방지를 위해 코루틴 사용 전에 StopCoroutine()를 사용함

IV.마름모 이미지가 점점 커지면서 투명해지는 이펙트 만들기
Vector3.Set(float x, float y, float z) : Vector3 변수를 설정(Set)하는 함수 = 으로 선언하는거랑 비슷함
상호작용 가능한 객체에 크로스헤어를 올리고 있으며 대화중이 아닌 상태에서 계속 돌아가는 무한반복 코루틴 만들기
IEnumerator Co_InteractionEffect()
    {
        float delayTime = 0.02f;
        WaitForSeconds ws = new WaitForSeconds(delayTime);

        // 상호작용 가능한 객체에 크로스헤어를 올리고 있으며 대화중이 아닌 상태에서 계속 돌아가는 무한반복 코루틴
        while (interactable && !DialogueManager.instance.isTalking)
        {
            Color color = img_InteractionEffect.color;
            color.a = 0.5f;

            img_InteractionEffect.transform.localScale = new Vector3(1.3f, 1.3f, 1.3f);
            Vector3 img_Scale = img_InteractionEffect.transform.localScale;

            while(color.a > 0 && !DialogueManager.instance.isTalking && interactable)
            {
                color.a -= 0.01f;
                img_InteractionEffect.color = color;
                img_Scale.Set(img_Scale.x + delayTime, img_Scale.y + delayTime, img_Scale.z + delayTime);
                img_InteractionEffect.transform.localScale = img_Scale;
                yield return ws;
            }
            yield return null;
        }
    }

V. 대화 중에는 상호작용 UI 안보이게 예외처리하기

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 1 데이터 파싱 및 엑셀 관리 ** 존나 중요하며 존나 길고 존나 어렵고 존나 재밌는 파트 ** 이번 파트는 전체적인 흐름만 적고 디테일한건 주석처리함
방대한 양의 대사들을 유니티에서 관리하면 비효율적이기 때문에 대사들을 엑셀 파일에서 관리하고 ,로 구분하는 데이터 자료형인 CSV(Comma Split Value)로 파싱 후 유니티로 불러들여 대화 기능을 구현

대사 클래스 (Dialogue Script) -> 대사 이벤트 클래스 (Dialogue Script) -> 엑셀파일 파싱 클래스 (DialogueParser Script) -> 파싱된 데이터를 저장하는 데이터베이스 매니저 클래스 (DataBaseManager Script) 
-> 상호 작용 이벤트 클래스 (InteractionEvent Script) -> 상호작용 컨트롤러 (InteractionController Script)에서 사용

1. 엑셀 데이터를 담을 틀을 가진 커스텀 클래스 2개 제작 (Dialogue Script)
이름과 대사(배열) 변수를 가진 Dialogue 클래스 Dialogue를 배열로 가지고 있고 엑셀 파일의 몇 번째 줄부터 몇 번째 줄까지를 가져올지 정하는 Vector2 변수를 가지고 있는 DialogueEvent 클래스 선언 
이 스크립트는 MonoBehaviour을 상속받지 않으므로 오브젝트의 컴포넌트로 직접 넣을 수 없고 InteractionEvent에서 수정할 것이기 때문에 둘 다 [System.Serializable]를 선언해 인스펙터 창에서 수정 가능하게
만듬

2. 엑셀파일 파싱 클래스 제작 (DialogueParser Script)
줄과 열(,)을 기준으로 Split함수를 이용해 데이터를 나눠서 string[] 변수에 담고 반복문을 사용해 Dialogue Script의 변수를 형식에 맞게 선언 후 반환하는 함수 제작
엑셀 파일을 csv파일로 변환했을 때 visual studio를 통해서 csv파일을 열어서 빈 줄이 있는지 확인하기 비어있는 줄이 있으면 빈 줄을 가져오려고 해서 에러 뜸

3. 파싱된 데이터를 저장하는 데이터베이스 매니저 클래스 제작 (DataBaseManager Script)
줄에 매칭되는 Dialogue Script를 가지는 딕셔너리 변수 선언 후 2.에서 만든 함수를 통해 얻은 배열을 이용해 반복문을 이용해 변수에 값 대입 후 시작 행과 끝 행을 인자로 받아 받은 줄의 데이터들의 배열을 반환하는 함수 제작

4. 상호 작용 이벤트 클래스 제작 (InteractionEvent Script)
객체에 들어가는 실질적으로 데이터를 가지는 스크립트
[SerializeField] DialogueEvent dialogueEvent; 변수를 가지며 3.에서 만든 함수에 1.에서 선언한 Vector2 변수의 x, y 값을 형변환 후 대입해 원하는 데이터를 변수에 선언하는 함수 제작

5. 상호작용 컨트롤러 (InteractionController Script)에서 사용
이전 파트에서 제작한 이펙트가 터지는 순간에 다이로그 바가 뜨는 함수에 4.에서 만든 함수 사용부분 추가

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 2 대화 시스템 구현

1. 대화 기능 구현 (DialogueManager Script)
I. 대사 치환 
csv파일은 ,로 데이터를 구분하기 때문에 대사에 ,를 쓰지 못하고 대신 |을 사용했는데 Replace()함수를 사용해서 |를 ,로 치환하기
string.Replace(string oldValue, string newValue) : string 변수에 old변수가 포함되어 있으면 newValue로 치환해주는 함수

II. 대사 출력 
캐릭터 대화의 순서를 나타내는 talkIndex변수와 대사의 순서를 나타내는 contextCount변수 다음 대화로 넘어갈 수 있는지를 나타내는 isNext변수 선언 후 대화 기능 구현에 사용
Update()문에서 isNext && isTalking && 마우스 또는 키보드 입력 시 실행되는 Talk()함수 선언
대화 한번마다 contextCount++시키고  한 캐릭터가 가지는 대사의 길이와 같아지면 contextCount = 0으로 하고 talkIndex++ 후 다시 대사 시작 talkIndex가 Dialogue[] 의 길이를 넘기면 대화 종료
void Talk()
{
        isNext = false;
        txt_Dialogue.text = "";
        if (++contextCount >= dialogues[talkIndex].contexts.Length)
        {
            contextCount = 0;
            talkIndex++;
        }

        if (talkIndex < dialogues.Length) StartCoroutine(Co_TypeWriter());
        else EndTalk();
}

III. 대사 타이핑 효과 구현
코루틴을 이용하여 한글자씩 대사를 추가
IEnumerator Co_TypeWriter()
{
        Set_DialogueUI(true);
        txt_Name.text = dialogues[talkIndex].name;
        txt_Dialogue.text = "";

        string replaceText = dialogues[talkIndex].contexts[contextCount];
        replaceText = ReplaceText_ToComma(replaceText);
        for (int i = 0; i < replaceText.Length; i++)
        {
            txt_Dialogue.text += replaceText[i];
            yield return new WaitForSeconds(textDelayTime);
        }
        isNext = true;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 3 디테일 (글자색 변경 등등)

1. 글자색 변경 (DialogueManager Script)
I. 엑셀 파일에서 강조하고 싶은 부분 양 옆에 특수문자 넣기 ex) 내 이름은 ⓨ봉란ⓦ이야 잘 부탁해 (ⓨ : 노란색 ⓦ : 하얀색)

II.  코드에서 특수문자를 감지해 어떤 텍스트에 효과 줄지 선택하기
대사 출력 효과를 구현하면서 반복문에서 1글자씩 대사를 더했기 때문에 반복문 내에서 한글자씩 비교하면서 만약 특수문자면 관련 함수를 실행시킴

char effectChar = ' '; // 어떤 효과를 줄지 구분하는 문자
for (int i = 0; i < replaceText.Length; i++)
{
            if (Set_IsColorText(replaceText[i])) // 더할 텍스트가 특수문자라면
            {
                effectChar = replaceText[i];
                continue;
            }

            string addText = replaceText[i].ToString();
            txt_Dialogue.text += (effectChar != ' ' && effectChar != 'ⓦ') ? ColoringText(effectChar, addText) : addText;
            yield return new WaitForSeconds(textDelayTime);
}

III. HTML 태그로 text에 색깔 넣기

string ColoringText(char t_Effect, string affectText) // 받은 특수문자에 맞는 효과를 string 인자에 구현 후 return
{
        string returnText;
        switch (t_Effect)
        {
            case 'ⓨ':
                returnText = "<color=#FFFF00>" + affectText + "</color>";
                break;
        }
        return returnText;
}

HTML 태그는 텍스트 인스펙터 창에서는 드러나지만 실제 게임에서는 나오지 않고 텍스트에 관련 효과가 적용됨 HTML과 같이 <> 로 시작해 같은 태그의 </>로 닫히면 <b>(굵게 하기), <i>(글자 기울이기),
<Size=px>(크기) 등의 태그가 지원되며 텍스트의 메테리얼도 지정할 수 있음 ex) We are <material=2>texturally</material> amused (material=2는 메쉬의 메테리얼 배열의 인덱스 값)
또한 태그는 대소문자를 구분하지 않음 ex) <Size=10>Hi</Size>, <SIZE=10>Hi</SIZE>, <SIZE=10>Hi</SiZe> 모두 가능.

태그 관련 내용 Unity Manual : https://docs.unity3d.com/kr/530/Manual/StyledText.html

2. 줄바꿈하기
Unity에서 줄바꿈은 \n(escape문)이지만 엑셀에서의 \n은 텍스트이기 때문에 escape문으로 인식하기 위해 대체 
// \n 앞에 \(escape문)을 붙이면 뒤에 문자는 텍스트로 인식
replaceText = replaceText.Replace("\\n", "\n"); 

3. 나레이션 추가
나레이션은 이름이 없기 때문에 나레이션 중에는 NameBar숨기기
이름이 없는 것을 이용해 코드를 작성, 이름을 조건으로 넣었기 때문에 NameBar의 텍스트를 이 부분에서 작성해야함
if (dialogues[talkIndex].name == "") obj_NameBar.SetActive(false); 
else
{
            obj_NameBar.SetActive(true);
            txt_Name.text = dialogues[talkIndex].name;
}

II 색깔 강조
나레이션은 모든 대사 시안색으로 처리하기, 그냥 엑셀에서 나레이션 앞에 ⓒ붙이고 위에서 짠 코드에 추가하면 됨

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 5 - 1 카메라 타겟팅

1. 특정 트랜스폼에 카메라 타겟팅하기 (CameraController Script)
I. 조건 
타겟팅하려는 객체의 Transfrom을 받고 Coroutine을 사용하여 카메라가 조금씩 객체의 앞으로 카메라가 이동하며 객체를 바라보도록 회전는 기능 구현
이때 while의 조건에 포지션과 함께 두 방향 a, b 사이의 각도를 반환하는 Quaternion.Aagle(Quaternion a, Quaternion b)를 사용하여 각도가 어느정도 작아질 때까지 while을 돌림

while(transfrom.position != forwardTargerPosition || Quaternion.Aagle(transform.rotation, Quaternion.LookRotation(camDirection) ) >= 0.5f )
이때 Quaternion.LookRotation(Vector3 forward, Vector3, upwards = Vector3.up)은 오브젝트가 forward방향으로 회전했을 때의 rotation값을 나타내며 upwards = Vector3.up은머리가 향하는 방향을 나타내며 
생략 시 객체의 머리는 위를 향하게 된다 머리가 항상 위를 향하므로 y축만 계산한며 x, z의 rotation값은 0으로 나온다 결국 y축의 값만 얻을 수 있다.

unity Quaternion.Lookrotation Manual : https://docs.unity3d.com/kr/530/ScriptReference/Quaternion.LookRotation.html
Quaternion.Lookrotation 관련 블로그 : https://blog.naver.com/PostView.nhn?blogId=happybaby56&logNo=221324341865

unity Quaternion.Angle Manual : https://docs.unity3d.com/kr/530/ScriptReference/Quaternion.Angle.html

II 이동 및 회전
코루틴의 대기와 현재 위치에서 목표지점까지 지정한 값만큼 움직이는 Vector3.MoveTowards(Vector3 currnet, Vector3 target, float maxDistanceDelta) 를 이용하여 카메라를 이동시킨다
회전은 Quaternion.Lerp()함수를 이용해 이동시킨다.

IEnumerator Co_CameraTargetting(Transform p_Targer, float p_CameraSpeed = 0.05f)
{
        Vector3 targetPosition = p_Targer.position;
        Vector3 forwardTargerPosition = targetPosition + p_Targer.forward * 1.5f;
        Vector3 camDirection = (targetPosition - forwardTargerPosition).normalized;

        while (transform.position != forwardTargerPosition || Quaternion.Angle(transform.rotation, Quaternion.LookRotation(camDirection) ) >= 0.5f )
        {
            transform.position = Vector3.MoveTowards(transform.position, forwardTargerPosition, p_CameraSpeed);
            transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(camDirection), p_CameraSpeed);
            yield return null;
        }
}

unity Vector3.MoveTowards Manual : https://docs.unity3d.com/kr/530/ScriptReference/Vector3.MoveTowards.html

III. 코루틴 충돌
코루틴 충돌을 방지해 코루틴을 멈춰야 하는데 인자가 2개이므로 문자열 방식으로 멈추지 못하기 때문에 StopAllCoroutine()을 사용한다. StopAllCoroutine()은 사용한 스크립트 내의 코루틴만 멈추기 때문에
여기에서는  Co_CameraTargetting()외에 다른 코루틴을 멈추지 않는다.

2. 코루틴 사용
** 강의에서는 객체의 Transfrom 변수를 인스펙터 창에서 일일히 선언하였는데 나는 만약 1000번의 대화를 만든다고 하면 이건 말도 안되는 노가다라고 생각해 다른 방식으로 구현하기를 원했고 결국 해냈다. **

I. 씬에 있는 모든 대화 객체의 이름을 key로 Transform을 value로 가지는 딕셔너리 (CharacterManager Script)
강의에서는 엑셀 파일에 대화하는 주체의 이름을 작성했기 때문에 나는 "그냥 이름하고 Transform하고 매치시키면 안되나?"라고 생각했고 이럴 때 딕셔너리만한 자료구조가 없다.
하지만 내 생각대로 하려면 게임 시작 전에 딕셔너리 안에 Transform 변수를 담기 위해 인스펙터 창에 딕셔너리를 표시해야하는데 unity에서는 이를 지원하지 않았고 결국 유튜브 영상을 보고 구현했다.
인스펙터 창에 딕셔너리 표시하는 방법 : https://www.youtube.com/watch?v=sivvCb5AERc (그냥 에셋 임포트해서 사용하는 영상)

II. Dialogue의 tf_Target 변수 DialogueEvent에 엑셀 파일 채우면서 같이 채우기 (InteractionEvent Script)
Dialogue는 대사를 치는 캐릭터를 기준으로 개수가 정해지므로 DialogueEvent의 Dialogue[] dialogues; 의 길이만큼 반복문을 돌리고 Dialogue의 tf_Target 변수를 선언했다.

for(int i = 0; i < dialogueEvent.dialogues.Length; i++) // tf_Target 대입
{
            Dialogue dialogue = dialogueEvent.dialogues[i]
            dialogue.tf_Target = CharacterManager.instance.dic_Character[dialogue.name];

            dialogueEvent.dialogues[i] = dialogue;
}

III. 예외처리
주인공이 말할 경우나 나레이션은 Dictionary에서 찾지 못하는 에러와 카메라가 타겟팅할 객체가 null이 되는 에러가 생긴다 특히 딕셔너리 관련 에러는 스크립트가 멈추기 때문에 꽤나 심각한 버그다
이를 위해 Dictionary에 name "주인공" 이거나 ""경우에 null을 넣어 타겟팅 객체에 null값을 주도록 하고 만약 객체의 값이 null이거나 이전과 같은 객체라면 카메라 타겟팅을 하지 않도록 한다.

IV. 타겟팅을 하고싶지 않을때
이 코드는 대사를 치는 캐릭터에게 '무조건' 카메라가 타겟팅하게 되어있다. 만약 인스펙터 창에서 채웠으면 사람이 임의로 정할 수 있었겠지만 Script로 채우는 것이기 때문에 그렇게 할 수 없다.
그래서 타겟팅하지 않을 캐릭터의 이름에는 엑셀 파일의 이름앞에 ⒳를 붙이고 이를 코드에서 감지하여 ⒳를 ""로 바꾸고 tf_Target에 null값을 주도록 하였다.
for(int i = 0; i < dialogueEvent.dialogues.Length; i++)
{
            Dialogue dialogue = dialogueEvent.dialogues[i];

            // 이름 앞에 ⒳가 붙어 있으면 타겟팅 안하는거임
            if (dialogue.name[0] != '⒳') dialogue.tf_Target = CharacterManager.instance.dic_Character[dialogue.name];
            dialogueEvent.dialogues[i] = dialogue;
}

또한 NameBar에 이름이 그대로 가지 않게 하기위해 이름 설정 부분을 수정한다.

if (name[0] == '⒳') name = name.Replace("⒳", "");
txt_Name.text = name;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 5 - 2 카메라 리셋

1. 카메라 리셋하기 (CameraController Script)
I. 목표 : 대화가 끝나면 대화를 시작하기 전의 위치로 돌아오고 각도는 (0, 0, 0) 으로 돌리기

II. 제작 및 사용 
대화 전 위치와 각도를 담을 변수를 만들고 대화가 시작할 때 카메라의 위치를 기억하는 함수를 만들고 대화가 시작할 때 실행
Part 5 - 1와 비슷한 형식으로 원본 위치로 돌아가는 코루틴을 만들고 대화가 끝날 때 실행

2. 디버깅 및 디테일
I. 각도 버그
카메라를 리셋하고 나면 갑자기 카메라 각도가 바뀌는데 이는 PlayerController에서 전에 있던 앵글 변수값을 각도에 적용해서 생기는 버그 그렇기에 관련 변수를 0으로 만드는 함수를 만들고 카메라 리셋하기 전에 사용

II UI 디테일
대화가 끝나자마자 바로 UI가 켜지는데 부자연스럽기 때문에 카메라 리셋이 끝나고 UI가 켜지게 하기 위해 카메라 리셋 마지막 부분에 UI켜지게 하기

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 5 - 3 디테일 (세부 조정)
1. 카메라 리셋이 중복하게 일어날 때 ** 나는 코드를 다르게 짜서 문제가 일어나지 않지만 해결 방법이 알아두면 좋을 것 같아서 적음 **
현재 코드는 AllStopCoroutine()을 사용하므로 카메라 리셋이 중복되서 일어날 경우 카메라 리셋 시작할 때 실행되는 대기 코드 때문에 카메라 무빙이 끊기는 듯한 모습을 보여줌
이를 해결하기 위해 Coroutine 변수를 선언하여 카메라 타겟팅을 넣고 변수가 카메라를 리셋할 때 null이 아니면 카메라 타겟팅 코루틴을 멈추고 카메라 리셋 실행 이러면 카메라 리셋은 멈추지 않으므로 끊기는 듯한 연출을 없어짐 (나는 카메라 리셋 코루틴이 중복 실행되는걸 방지해서 카메라 리셋이 실행중이 아닐때만 카메라가 리셋하는 코드도 추가할 듯)

2. 네임바가 없어지지 않는 버그 (난 마지막에 알아서 꺼져서 버그 없음)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 6 - 1 스프라이트 교체

1. 액셀 파싱
엑셀 파일의 행(row)을 추가하여 스프라이트가 바뀌기를 원하는 지점에 스프라이트의 이름을 복사해서 붙여넣고 Dialogue Script에 string[] 형식의 변수를 선언하고 DialogueParser에서 파싱한 부분해 대사와 똑같은 형식으로  대입함 (캐릭터가 한번에 대화할 때 여러 번 스프라이트를 바꿀수도 있기 때문에 배열로 선언)

2. 스프라이트 교체 (SpriteManager Script) 
현재 캐릭터스프라이트는 콜라이더나 스크립트를 가지고 있는 빈 객체에 자식 개체로 있기 때문에 GetComponentInChildren<SpriteRenderer>(); 을 통해 스프라이트 렌더러를 가져오고 스프라이트 교체 시 적용시키고자 하는 스프라이트는 Loda("Characters/" + spriteName) 을 통해 스프라이트에 접근하고 as Sprite를 통해 파일을 스프라이트로 변환해줌 이때 가져온 파일이 스프라이트 파일이 아니라 변환이 불가능하면 null값이 들어가는데 이러면 오류가 생길수도 있고 하니 typeof(Sprite)를 통해 타입이 같은지 확인함

SpriteRenderer sr = targer.GetComponentInChildren<SpriteRenderer>();
spriteName = spriteName.Trim(); // 원인은 모르겠지만 글자 마지막에 공백이 들어가서 공백 지우는 함수 사용
Sprite sprite = Resources.Load("Characters/" + spriteName, typeof(Sprite)) as Sprite;

이때 가져온 스프라이트가 현재 캐릭터가 보여주고 있는 스프라이트가 아니거가 null 값도 아니라면 스프라이트렌더러의 스프라이트를 교체
sr.sprite = sprite;
교체 후에 투명도 값을 올리는 효과도 구현했지만 늘 보는 코루틴 공식이므로 생략

3. 디버그
일단 스프라이트 이름 마지막에 공백이 들어가는 버그도 있었지만 위 코드에서 주석처리로 언급했기 때문에 넘어가고 일단 나는 기본적으로 강의에서 사용하는 코드랑 방향성이 달라서 내가 직접 인스펙터 창에서 세부적인걸 조정하지 않고 다 자동으로 설정하게 했는데 이러면 주인공이 말하거나 독백할 때 tf_target 변수가 null이기 때문에 주인공이 말하고 있거나 마지막 대사를 한 후 대화가 끝나서 스프라이트를 초기화시킬 때 문제가 생긴다 때문에 tf_Target 변수의 의미를 카메라가 타겟팅하려는 캐릭터가 아니라 현재 대화 중인 캐릭터로 의미를 확장시켜 위에서 말한 문제점을 고쳤고 이로 인해 후에 캐릭터와 관련하여 어떠한 기능을 추가할 때 더 쉽게 확장할 수 있을 것이다.
// target은 현재 대화 상대를 의미 주인공이 말하거나 독백할때도 target에는 대화상대가 들어감
Transform currentTarget = null;
if (dialogue.tf_Target == null) dialogue.tf_Target = currentTarget;
else currentTarget = CharacterManager.instance.dic_Character[dialogue.name];

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 6 - 2 디테일 (뒷모습과 회전)

1. 캐릭터 뒷모습
I. 캐릭터 부모 오브젝트에 스프라이트 오브젝트를 복사하고 포지션을 약간 뒤로 옮긴 후 색깔을 검정색으로 해서 뒤에서 보면 아예 검은색으로 보이도록 함

II. 기존에 스프라이트 교체 시 투명도를 조금씩 더하는 연출을 구현했는데 뒤에 검은색이 보이면 부자연스럽기 때문에 SpriteRenderer을 GetComponentsInChildren<>으로 배열로 가져온 후에 0번째에 스프라이트가 1번째에 그림자가 오도록 해서 그림자에도 똑같이 스프라이트를 바꾸고 투명도를 높이는 연출을 적용시킴

2. 캐릭터 플레이어 바라보기 (CharacterSpin Script)
I. 캐릭터를 바라볼 때 회전값을 가지는 Quaternion 변수와 transform.eulerAngles에 대입할 Vector3변수를 선언 후 y축의 회전값만 바뀌어야하기 때문에 회전값에서 y값만 Vector변수에 전달 후 회전값 변경
void Update()
{
        lookAngle = Quaternion.LookRotation(tf_Target.position);
        lookEuler = Vector3.up * lookAngle.eulerAngles.y;
        transform.eulerAngles = lookEuler;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 7 페이드 인 아웃

1. enum 타입 덮어쓰기 (InteractionEvent Script)
원래는 카메라 리셋 강의에서 했던건데 나는 그때 코드를 다르게 짜서 안했었음 근데 이번에는 아무레도 따라하는게 편할 것 같아서 따라함
인스펙터 창에서 선언해둔 변수를 적용하기 위해 다른 instanceDialogue를 인스턴스해서 만들고 거기에 엑셀 데이터를 대입 후 인스펙터에 있는 원본 DialogueEvent 클래스의 정보를 대입하고
원본에 제작한 DialogueEvent를 대입함 카메라 관련 연출이 있을때만 후에 다른 기능이 추가된다해도 "인스펙터 창에서 선언이 필요할 때만" 인스펙터 창을 선언하고 나머지는 자동으로 할꺼기 떄문에
원본의 크기가 엑셀 데이터를 파싱받은 instanceDialogues의 정보를 받을 공간이 있을때만 덮어쓰기를 함

public void SetDialogueEvent()
{
        DialogueEvent instanceDialogues = new DialogueEvent();
        instanceDialogues.dialogues = new Dialogue[(int)dialogueEvent.line.y - (int)dialogueEvent.line.x + 1]; // dialogues의 크기 결정 (크기는 dialogueEvent에서 결정)
        instanceDialogues.dialogues = DataBaseManager.instance.GetDialogues((int)dialogueEvent.line.x, (int)dialogueEvent.line.y); // dialogues 선언

        for (int i = 0; i < instanceDialogues.dialogues.Length; i++) // 각종 변수 대입
        {
            Dialogue dialogue = instanceDialogues.dialogues[i];

            // 이름 앞에 ⒳가 붙어 있으면 타겟팅 안하는거임 
            if (dialogue.name[0] != '⒳') dialogue.tf_Target = CharacterManager.instance.dic_Character[dialogue.name];

            // target은 현재 대화 상대를 의미 주인공이 말하거나 독백할때도 target에는 대화상대가 들어감
            if (dialogue.tf_Target == null) dialogue.tf_Target = currentTarget;
            else currentTarget = dialogue.tf_Target;

            if (dialogueEvent.dialogues.Length > i) // 인스펙처 장에서 선언한 dialogueEvent 덮어쓰기용
            {
                dialogue.cameraType = dialogueEvent.dialogues[i].cameraType;
            }
        }
        // 선언 후 반환
        dialogueEvent.dialogues = instanceDialogues.dialogues;
}

2. 카메라 fade 연출 (FlashManager Script)
I. fade 연출 구현
인수로 bool 값을 받아 white인지 black 이미지인지 구분 좀 재밌었던 부분은 image로 구현을 다르게 하는게 아니라 하얀색 이미지 하나에 color 변수 2개를 만들고 하나는 하얀색 하나는 검은색을 대입하고 bool인자값에 따라 이미지에 color를 넣어 구현을 했다는거, 그리고 늘 하던 코루틴 while문으로 투명도 구현
public void FadeOut(bool isWhite, bool isSpeed = false)
{
        Color color = isWhite ? whiteColor : blackColor;
        float speed = isSpeed ? fadeSlowSpeed : fadeSpeed;
        StartCoroutine(Co_FadeOut(color, speed));
}

IEnumerator Co_FadeOut(Color color, float speed)
{
        isFade = true;
        color.a = 0;
        fadeImage.color = color;

        while(color.a < 1)
        {
            color.a += speed;
            fadeImage.color = color;
            yield return ws;
        }
        isFade = false;
}

II. fade 연출 구분 (DialogueManager Script)
swich문을 사용해 타입마다 다른 함수 실행 후 대화 관련 UI를 끄고 fade 연출이 끝날 때까지 대기한 후 다시 대화 시작하는 함수 구현
IEnumerator Co_FadeCamera(CameraType cameraType)
{
        switch (cameraType)
        {
            case CameraType.FadeIn: splashManager.FadeIn(false); break;
            case CameraType.FadeOut: splashManager.FadeOut(false); break;
            case CameraType.FlashIn: splashManager.FadeIn(true); break;
            case CameraType.FlashOut: splashManager.FadeOut(true); break;
        }
        Set_DialogueUI(false);
        yield return new WaitUntil(() => !splashManager.isFade);
        StartCoroutine(Co_TypeWriter());
}

III. fade연출 사용 (DialogueManager Script)
CameraType이 Default면 카메라 타겟팅을 실행하고 아니면 fade연출 실행 또한 화자가 바뀔 때 대화를 끝날 건지 계속할건지 결정하도록 Talk() 함수를 수정
void Talk()
{
        isNext = false;
        txt_Dialogue.text = "";
        if (++contextCount >= dialogues[talkIndex].contexts.Length) // 대화의 화자가 바뀔 때
        {
            contextCount = 0;
            if (++talkIndex < dialogues.Length) // 각종 카메라 연출
            {
                if (dialogues[talkIndex].cameraType == CameraType.Default) StartCoroutine(Co_CameraTargetTing());
                else StartCoroutine(Co_FadeCamera(dialogues[talkIndex].cameraType));
            }
            else EndTalk(); // 화자가 바뀔때만 talkIndex가 오르기 때문에 여기서 대화 종료 여부 결정
            return;
        }
        // 똑같은 화자가 2번 이상 말할 때 별도의 조건 없이 그냥 대사 출력
        StartCoroutine(Co_TypeWriter());
}






































