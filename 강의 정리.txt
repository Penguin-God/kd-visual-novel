Part 1 기본 무대 및 UI 세팅
I. Edit -> Grid and Snap Setting을 이용하여 편하게 맵 만들기 (마우스를 통해 오브젝트를 한번 움직일 때마다 얼마나 움직일지를 설정할 수 있음)
II. UI 에서 Anchor Position을 설정할 때는 부모는 상단, 하단 처럼 전체적인 틀을 잡고 자식을 구석과 같이 디테일하게 설정하면 좋음 가운데에 있는 애들은 굳이 설정 안해도 해상도 맞춰짐 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 1 크로스헤어 구현
1. [SerializeField] 는 private의 보호 수준은 유지하면서 인스펙터 창에 변수의 값을 보이게 함(할당도 가능)

2. 크로스헤어가 마우스 따라가게하기

I. 크로스 헤어의 포지션 값 
크로스헤어 UI는 Canvas의 자식 오브젝트이므로 원하는 좌표 값을 얻거나 할당하기 위해서는 부모 객처를 기준으로 상대적으로 얼마나 떨어져 있는지를 나타내는 localposition을 사용해야함

이때 Input.mouseposition 값을 크로스헤어의 포지션값에 그대로 적용했을 때 Input.mouseposition값은 화면 왼쪽 아래를 기준으로 0, 0을 가지기 때문에 마우스를 왼쪽 아래 구석에 가져가면 크로스헤어가 가운대로 오는 기적을 감상할 수 있기 때문에 x, y축에 스크린의 넓이와 높이의 반만큼 빼줘야함 그러면 왼쪽 아래 구석에 마우스를 놀 때 크로스 헤어의 포지션 값에 0, 0에서 화면 크기의 넓이와 높이의 반만큼 뺸 값이 대입되기 때문에 마우스와 똑같이 위치함

II. Screen : 디스플레이 정보에 접근하는데 사용하며 지원되는 해상도 목록을 가져오거나 변환하는데 사용됨
Screen.width : 해상도를 기준으로 화면의 넓이를 가져오며 단위는 픽셀을 사용(height는 높이) 

III. 주의사항
스크린의 크기는 해상도를 기준으로 가져오고 크로스헤어는 UI이므로 Canvas Sclaer의 Reference Resolution 값을 기준으로 위치하기 때문에 Reference Resolution의 값과 해상도 값을 일치시켜야함
만약 해상도를 Reference Resolution 값보다 크게 하면 스크린 값이 Canvas보다 크게 설정되어 크로스헤어의 포지션이 마우스 위치와 달라짐

Screen 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Screen.html
Input.mousePosition 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Input-mousePosition.html

3. 크로스헤어가 화면 밖으로 나가지 않게 하기
필요성 : Input.mouseposition는 마우스 포인터가 화면 밖에 있어도 위치를 보고하기 때문에 크로스헤어가 화면밖으로 나가 보이지 않을 수 있어 크로스헤어의 위치에 제한을 두어 화면 밖으로 나가지 않게 함

I. Mathf.Clamp()함수 
Mathf.Clamp(float value, float min, float max) : 기본적으로 value의 값을 반환하지만 value가 min보다 작으면 min을 max보다 크면 max값을 반환함 즉 기본적으로 vlaue를 반환하되 원하는 범위만큼 제한을 둔 값을 반환할 수 있음 value의 값에는 영향을 주지 않고 오직 반환값만 제한됨 

II. 마우스 포지션 값과 스크린 크기 값에 기반해 먼저 크로스헤어의 x, y 변숫값을 구한 후 그 변수에 이 함수를 통해 스크린의 크기만큼 제한한 값을 대입해 크로스헤어가 화면 밖으로 나가는 것을 방지함 

private float cursorMargin = 30; // 마진을 다 크로스헤어의 모든 부분이 화면에 보이게 하기 위한 여백값
// 크로스 헤어의 좌표값 구함
float corsshair_X = Input.mousePosition.x - Screen.width / 2;
float corsshair_Y = Input.mousePosition.y - Screen.height / 2;

// corsshair가 화면 밖으로 나가는거 방지하기 위해 스크린 크기만큼 제한한 값을 다시 할당
corsshair_X = Mathf.Clamp(corsshair_X, -Screen.width / 2 + cursorMargin, Screen.width / 2 - cursorMargin);
corsshair_Y = Mathf.Clamp(corsshair_Y, -Screen.height / 2 + cursorMargin, Screen.height / 2 - cursorMargin);
tf_Corsshair.localPosition = new Vector2(corsshair_X, corsshair_Y);

4. 강의 내용 외의 시도

I. RectTranform을 사용할 경우 크로스헤어가 마우스를 그래도 따라가지만 여전히 좌측 하단이 0, 0이기 때문에 Screen의 크기를 이용해 크로스헤어의 범위에 제한을 두는 데에 문제가 생김
RectTransform을 사용하면 마우스를 그대로 따라가는 이유는 RectTransform도 좌측 하단이 0, 0 이디 때문임
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 2 뷰 회전 (크로스 헤어)

1. 크로스헤어가 끝부분에 있으면 그쪽 방향으로 회전하기

I. Part 2 - 1에서 구현한 크로스 헤어의 위치값이 스크린의 절반보다 크거나 작으면 작동하는  조건문 제작
if( corsshair_X > half_ScreenWidth - 80 || corsshair_X > -half_ScreenWidth + 80 )

II. 삼항 연산자를 통해 x좌표의 부호에 따라 회전값 변수에 회전 속도 변수를 더하거나 뺌
currentCameraAngle_Y += ( corsshair_X > 0 ) ? rotateSpeed : -rotateSpeed; 

III. 연산이 이뤄진 회전값 변수에 Mathf.Clamp() 함수를 이용하여 회전값에 제한을 둔 후 카메라 회전값에 대입함
currentCameraAngle_Y = Mathf.Clamp(currentCameraAngle_Y, -look_X_Limit, look_X_Limit);
같은 방법으로 currentCameraAngle_X를 구한 후 대입( 이때 x축 회전값의 방향은 더하면 내려가고 빼면 올라가기 때문에 삼항연산자 부호를 반대로 해야함)
th_Camera.rotation = Quaternion.Euler(new Vector3(currentCameraAngle_X, currentCameraAngle_Y, 0));

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 3 뷰 이동 및 회전 (방향키)

1. 키보드를 이용한 회전 구현

I. 수평 수직 키 입력을 받는 Input.GetAxisRaw값을 이용해 Part 2 - 2의 방법을 그대로 적용하여 회전 구현 (GetAxis값은 입력에 따라 음수 양수 값이 나오기 때문에 삼항연사자는 필요 없음) 
이때 Input.GetAxisRaw는 -1, 0, 1의 값 3가지만 반환하며 Input.GetAxis는 -1, 1까지의 값을 반환한다 즉 부드러운 이동은 Input.GetAxis를 키보드와 같이 입력 시 바로 반응해야 하는 경우에는 Input.GetAxisRaw를 사용한다.
float getKey_X = Input.GetAxisRaw("Horizontal");
if (getKey_X != 0) currentCameraAngle_Y += getKey_X * playerRotateSpeed;


2. 플레이어 이동 구현

I. 회전할 때 회전 방향과 같은 방향으로 이동 나는 강의에서랑 조금 다르게 float 파라미터를 가진 함수를 만들어 인자값의 부호에 따라 속도 변수만큼 움직이는 함수를 만든 후 회전 조건문 안에 넣음
void MoveX(float moveDirection)
{
    float move_X = (moveDirection > 0) ? playerMoveSpeed : -playerMoveSpeed;
    tf_Camera.localPosition += Vector3.right * move_X;
}

II. 실제 함수 사용
if(corsshair_X > half_ScreenWidth - 80 || corsshair_X < -half_ScreenWidth + 80)
{
    currentCameraAngle_Y += (corsshair_X > 0) ? playerRotateSpeed : -playerRotateSpeed;
    MoveX(corsshair_X); // 회전의 기준이 되는 corsshair_X를 argument값으로 넣음 (키보드는 GetAxisRaw값)
}
Y축 이동은 방향만 바꾼 후 똑같이 함수 만들고 똑같이 적용함


3. 플레이어 이동 위치 제한 구현
카메라 위치가 지정한 변숫값보다 크거나 작으면 그 포지션 값을 변수값으로 고정
if(tf_Camera.localPosition.x > move_X_Limit || tf_Camera.localPosition.x < -move_X_Limit)
{
	tf_Camera.localPosition = new Vector3( (tf_Camera.localPosition.x > 0) ? move_X_Limit : -move_X_Limit ,  tf_Camera.localPosition.y, tf_Camera.localPosition.z);
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 4 디테일 (Spin 및 추가 UI)
1. 해당 방향으로 회전을 못할 때 회전을 못한다는 것을 알려주는 UI 제작

I. UI 4개 만들고 현재 회전값이 지정한 최대 방향값보다 높으면 해당 방향의 금지 모양 UI의 SetActive(true)하고 아니면 false하기

2. 크로스헤어의 노란색 부분이 아톰 홈페이지마냥 계속 빙글빙글 돌아가게 만들기 (Spin Script)

I. transform.Rotate(Vector3 eulers) : argument값의 Vector3만큼 회전시키는 함수 Translate()랑 비슷함
II. Time.deltaTime : 이전 프레임과 현재프레임의 시간차이를 반환함 1초에 60프레임이라면 1 / 60 반환 Update문에서 속도 변수에 곱하면 1초에 원하는 값만큼 움직여서 따로 복잡한 연산이 필요없음
transform.Rotate(spinDir * spinSpeed * Time.deltaTime);

3. 상수를 변수로 바꾸기

I. const와 readonly
공통점 : 둘 다 변수를 상수로 선언해 재할당이 불가능하다

차이점 : const는 컴파일 타입의 상수이고 readonly는 런타임 타입의 상수이다. 즉 const는 컴파일 시 변숫값을 가져오고 readonly는 exe, dll 등의 파일 실행 시 값을 가져온다 이 때문에 const를 사용하면 조금이라도 프로그램에 더 빠르게 접근 가능하지만 상숫값을 변경할 때 그 값과 관련된 프로젝트를 모두 다시 컴파일해야하는 단점이 있다 때문에 상숫값 변경 시 재 컴파일을 하지 않고 사용하는 생성자 단계에서 변수에 값을 할당하는 readonly가 더 각광받고 있는 추세이다.

관련 내용 블로그 : https://holjjack.tistory.com/95

II. 카메라 상수 변수로 바꾸기
카메라의 Y포지션이 0이 아닌 1이기 때문에 카메라 포지션 제한값을 둘 때 1에 지정한 위치값을 더하는 형식으로 카메라 위치를 제한했는데 이를 게임 시작 시 현재 카메라 Y값을 변수에 대입해 1대신에 사용
이럴 경우 후에 카메라의 위치가 바뀌어도 카메라의 위치값을 변수에 대입하기 때문에 코드를 건드리지 않아도 됨

originPos_CameraY = tf_Camera.localPosition.y;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 1 상호작용
1. 상호작용 가능한 객체 위에 마우스 울리면 UI 변하기
I. 상호작용 전용 여러 이미지를 겹치게 해서 UI Interactive_Corsshair 제작하기

2. 카메라에서 Ray발사하기 (IntreactionCortroller Script)

I. 게임 카메라 상에서의 마우스 포지션을 게임에서의 월드 포지션으로 바꾼 후 그 값을 이용하여 Ray를 쏴야 함
이를 구현하기 위해 Camera 클래스에 있는 함수인 SceenPointToRay()에 마우스 포지션 값(카메라가 보고있는 스크린의 점)을 넣어 ray를 반환함
이때 ray는 발사할 Ray의 시작점과 방향을 둘 다 Vector 값으로 가짐  ex) Origin : (1, 0, 3), Dir : (0.7, 0, 0.3)
if (Physics.Raycast(cam.ScreenPointToRay(mousePosition), out rayHit, 100))

ScreenPointToRay 관련 Unity Manual : https://docs.unity3d.com/kr/current/Manual/CameraRays.html
Physics.Raycast 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Physics.Raycast.html

II. 
ray가 맞은 오브젝트의 태그가 Interaction이면 Interactive_Corsshair를 아니면 Normal_Corsshair를 보여줌

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 2 상호작용 이펙트
1. 상호작용 파티클 이펙트 만들기

I. 목표 : 물음표 모양을 한 스프라이트 이미지를 던지는 형식의 이펙트를 연출할 것이므로 딱 한번만 파티클이 나와야 하고 나오는 파티클을 미리 준비한 스프라이트 이미지로 바꾸어야함

II. Emission의 Rate over Time (시간 경과에 따른 입자 방출 수)를 0으로 하고 Bursts (시작 시 방출하는 파티클)의 Count를 1로 함 그리고 파티클의 모양을 스프라이트로 하기 위해 Texture Sheet Animation의 Mode를 Grid에서 Sprites로 바꾼 후 미리 준비해둔 스프라이트를 넣음 그리고 Render에서 Material을 Default-ParticleSystem으로 설정해야 보라색 버그 입자가 아닌 스프라이트가 정상적으로 나옴

III. 그대로 날아가면 재미가 없기 때문에 회전하면서 날아가도록 Rotation over Lifetime에서 Separate Axes를 체크 후 회전 방향을 설정함

IV. 이펙트가 물체에 닿았을 때 터지는 이펙트 만들기
사이즈를 줄이고 StartSpeed를 빠르게 한 후 Bursts의 Count를 20으로 설정하고 사방으로 퍼지도록 Shape를 shpere로 Radius(입자가 뿜어져 나올 영역의 크기로 0에 가까울 수록 한 점에서 뿜어져 나옴)를 0에 가깝게 설정 후 Size over Lifetime을 이용해 입자가 점점 작아지게 설정하고 입자가 원이 아니라 선처럼 뻗어나가도록하게 하기 위해 Render에서 Render Mode를 Billboard에서 Stretched Billboard로 설정 후 Speed나 Length에 따라 찢어지는 정도를 설정 

2. 파티클 투척하기

I. 상호작용이 가능한 상태에서 좌클릭을 하면 파티클이 실행됨 if(Input.GetMouseButtonDown(0) && interactable)

II. 부드러운 움직임을 위해 Lerp(Vector3 start, Vector3 end, float t) 함수를 이용해 이동 (end - start)/ t 만큼 움직임 0.5f면 1 / 2만큼 움직임
상호작용하려는 물체와 충분히 가까워지면 HitEffect를 Play함

III. 오브젝트의 Pivot를 바꿔서 이펙트를 타겟의 transform.position을 기준으로 발사할 때 이미지의 상반신을 향하게끔 바꿈
pivot 변경하는 방법을 다룬 블로그 : https://mariageunit.blogspot.com/2019/07/unity-1.html







