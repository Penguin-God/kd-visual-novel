aPart 1 기본 무대 및 UI 세팅
I. Edit -> Grid and Snap Setting을 이용하여 편하게 맵 만들기 (마우스를 통해 오브젝트를 한번 움직일 때마다 얼마나 움직일지를 설정할 수 있음)
II. UI 에서 Anchor Position을 설정할 때는 부모는 상단, 하단 처럼 전체적인 틀을 잡고 자식을 구석과 같이 디테일하게 설정하면 좋음 가운데에 있는 애들은 굳이 설정 안해도 해상도 맞춰짐 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 1 크로스헤어 구현

1. [SerializeField] 는 private의 보호 수준은 유지하면서 인스펙터 창에 변수의 값을 보이게 함(할당도 가능)

2. 크로스헤어가 마우스 따라가게하기
I. 크로스 헤어의 포지션 값 
크로스헤어 UI는 Canvas의 자식 오브젝트이므로 원하는 좌표 값을 얻거나 할당하기 위해서는 부모 객처를 기준으로 상대적으로 얼마나 떨어져 있는지를 나타내는 localposition을 사용해야함

이때 Input.mouseposition 값을 크로스헤어의 포지션값에 그대로 적용했을 때 Input.mouseposition값은 화면 왼쪽 아래를 기준으로 0, 0을 가지기 때문에 마우스를 왼쪽 아래 구석에 가져가면 크로스헤어가 가운대로 오는 기적을 감상할 수 있기 때문에 x, y축에 스크린의 넓이와 높이의 반만큼 빼줘야함 그러면 왼쪽 아래 구석에 마우스를 놀 때 크로스 헤어의 포지션 값에 0, 0에서 화면 크기의 넓이와 높이의 반만큼 뺸 값이 대입되기 때문에 마우스와 똑같이 위치함

II. Screen : 디스플레이 정보에 접근하는데 사용하며 지원되는 해상도 목록을 가져오거나 변환하는데 사용됨
Screen.width : 해상도를 기준으로 화면의 넓이를 가져오며 단위는 픽셀을 사용(height는 높이) 

III. 주의사항
스크린의 크기는 해상도를 기준으로 가져오고 크로스헤어는 UI이므로 Canvas Sclaer의 Reference Resolution 값을 기준으로 위치하기 때문에 Reference Resolution의 값과 해상도 값을 일치시켜야함
만약 해상도를 Reference Resolution 값보다 크게 하면 스크린 값이 Canvas보다 크게 설정되어 크로스헤어의 포지션이 마우스 위치와 달라짐

Screen 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Screen.html
Input.mousePosition 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Input-mousePosition.html

3. 크로스헤어가 화면 밖으로 나가지 않게 하기
필요성 : Input.mouseposition는 마우스 포인터가 화면 밖에 있어도 위치를 보고하기 때문에 크로스헤어가 화면밖으로 나가 보이지 않을 수 있어 크로스헤어의 위치에 제한을 두어 화면 밖으로 나가지 않게 함

I. Mathf.Clamp()함수 
Mathf.Clamp(float value, float min, float max) : 기본적으로 value의 값을 반환하지만 value가 min보다 작으면 min을 max보다 크면 max값을 반환함 즉 기본적으로 vlaue를 반환하되 원하는 범위만큼 제한을 둔 값을 반환할 수 있음 value의 값에는 영향을 주지 않고 오직 반환값만 제한됨 

II. 마우스 포지션 값과 스크린 크기 값에 기반해 먼저 크로스헤어의 x, y 변숫값을 구한 후 그 변수에 이 함수를 통해 스크린의 크기만큼 제한한 값을 대입해 크로스헤어가 화면 밖으로 나가는 것을 방지함 

private float cursorMargin = 30; // 마진을 다 크로스헤어의 모든 부분이 화면에 보이게 하기 위한 여백값
// 크로스 헤어의 좌표값 구함
float corsshair_X = Input.mousePosition.x - Screen.width / 2;
float corsshair_Y = Input.mousePosition.y - Screen.height / 2;

// corsshair가 화면 밖으로 나가는거 방지하기 위해 스크린 크기만큼 제한한 값을 다시 할당
corsshair_X = Mathf.Clamp(corsshair_X, -Screen.width / 2 + cursorMargin, Screen.width / 2 - cursorMargin);
corsshair_Y = Mathf.Clamp(corsshair_Y, -Screen.height / 2 + cursorMargin, Screen.height / 2 - cursorMargin);
tf_Corsshair.localPosition = new Vector2(corsshair_X, corsshair_Y);

4. 강의 내용 외의 시도
I. RectTranform을 사용할 경우 크로스헤어가 마우스를 그래도 따라가지만 여전히 좌측 하단이 0, 0이기 때문에 Screen의 크기를 이용해 크로스헤어의 범위에 제한을 두는 데에 문제가 생김
RectTransform을 사용하면 마우스를 그대로 따라가는 이유는 RectTransform도 좌측 하단이 0, 0 이디 때문임

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 2 뷰 회전 (크로스 헤어)

1. 크로스헤어가 끝부분에 있으면 그쪽 방향으로 회전하기
I. Part 2 - 1에서 구현한 크로스 헤어의 위치값이 스크린의 절반보다 크거나 작으면 작동하는  조건문 제작
if( corsshair_X > half_ScreenWidth - 80 || corsshair_X > -half_ScreenWidth + 80 )

II. 삼항 연산자를 통해 x좌표의 부호에 따라 회전값 변수에 회전 속도 변수를 더하거나 뺌
currentCameraAngle_Y += ( corsshair_X > 0 ) ? rotateSpeed : -rotateSpeed; 

III. 연산이 이뤄진 회전값 변수에 Mathf.Clamp() 함수를 이용하여 회전값에 제한을 둔 후 카메라 회전값에 대입함
currentCameraAngle_Y = Mathf.Clamp(currentCameraAngle_Y, -look_X_Limit, look_X_Limit);
같은 방법으로 currentCameraAngle_X를 구한 후 대입( 이때 x축 회전값의 방향은 더하면 내려가고 빼면 올라가기 때문에 삼항연산자 부호를 반대로 해야함)
th_Camera.rotation = Quaternion.Euler(new Vector3(currentCameraAngle_X, currentCameraAngle_Y, 0));

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 3 뷰 이동 및 회전 (방향키)

1. 키보드를 이용한 회전 구현
I. 수평 수직 키 입력을 받는 Input.GetAxisRaw값을 이용해 Part 2 - 2의 방법을 그대로 적용하여 회전 구현 (GetAxis값은 입력에 따라 음수 양수 값이 나오기 때문에 삼항연사자는 필요 없음) 
이때 Input.GetAxisRaw는 -1, 0, 1의 값 3가지만 반환하며 Input.GetAxis는 -1, 1까지의 값을 반환한다 즉 부드러운 이동은 Input.GetAxis를 키보드와 같이 입력 시 바로 반응해야 하는 경우에는 Input.GetAxisRaw를 사용한다.
float getKey_X = Input.GetAxisRaw("Horizontal");
if (getKey_X != 0) currentCameraAngle_Y += getKey_X * playerRotateSpeed;


2. 플레이어 이동 구현
I. 회전할 때 회전 방향과 같은 방향으로 이동 나는 강의에서랑 조금 다르게 float 파라미터를 가진 함수를 만들어 인자값의 부호에 따라 속도 변수만큼 움직이는 함수를 만든 후 회전 조건문 안에 넣음
void MoveX(float moveDirection)
{
    float move_X = (moveDirection > 0) ? playerMoveSpeed : -playerMoveSpeed;
    tf_Camera.localPosition += Vector3.right * move_X;
}

II. 실제 함수 사용
if(corsshair_X > half_ScreenWidth - 80 || corsshair_X < -half_ScreenWidth + 80)
{
    currentCameraAngle_Y += (corsshair_X > 0) ? playerRotateSpeed : -playerRotateSpeed;
    MoveX(corsshair_X); // 회전의 기준이 되는 corsshair_X를 argument값으로 넣음 (키보드는 GetAxisRaw값)
}
Y축 이동은 방향만 바꾼 후 똑같이 함수 만들고 똑같이 적용함


3. 플레이어 이동 위치 제한 구현
카메라 위치가 지정한 변숫값보다 크거나 작으면 그 포지션 값을 변수값으로 고정
if(tf_Camera.localPosition.x > move_X_Limit || tf_Camera.localPosition.x < -move_X_Limit)
{
	tf_Camera.localPosition = new Vector3( (tf_Camera.localPosition.x > 0) ? move_X_Limit : -move_X_Limit ,  tf_Camera.localPosition.y, tf_Camera.localPosition.z);
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 4 디테일 (Spin 및 추가 UI)

1. 해당 방향으로 회전을 못할 때 회전을 못한다는 것을 알려주는 UI 제작
I. UI 4개 만들고 현재 회전값이 지정한 최대 방향값보다 높으면 해당 방향의 금지 모양 UI의 SetActive(true)하고 아니면 false하기

2. 크로스헤어의 노란색 부분이 아톰 홈페이지마냥 계속 빙글빙글 돌아가게 만들기 (Spin Script)
I. transform.Rotate(Vector3 eulers) : argument값의 Vector3만큼 회전시키는 함수 Translate()랑 비슷함
II. Time.deltaTime : 이전 프레임과 현재프레임의 시간차이를 반환함 1초에 60프레임이라면 1 / 60 반환 Update문에서 속도 변수에 곱하면 1초에 원하는 값만큼 움직여서 따로 복잡한 연산이 필요없음
transform.Rotate(spinDir * spinSpeed * Time.deltaTime);

3. 상수를 변수로 바꾸기
I. const와 readonly
공통점 : 둘 다 변수를 상수로 선언해 재할당이 불가능하다

차이점 : const는 컴파일 타입의 상수이고 readonly는 런타임 타입의 상수이다. 즉 const는 컴파일 시 변숫값을 가져오고 readonly는 exe, dll 등의 파일 실행 시 값을 가져온다 이 때문에 const를 사용하면 조금이라도 프로그램에 더 빠르게 접근 가능하지만 상숫값을 변경할 때 그 값과 관련된 프로젝트를 모두 다시 컴파일해야하는 단점이 있다 때문에 상숫값 변경 시 재 컴파일을 하지 않고 사용하는 생성자 단계에서 변수에 값을 할당하는 readonly가 더 각광받고 있는 추세이다.

관련 내용 블로그 : https://holjjack.tistory.com/95

II. 카메라 상수 변수로 바꾸기
카메라의 Y포지션이 0이 아닌 1이기 때문에 카메라 포지션 제한값을 둘 때 1에 지정한 위치값을 더하는 형식으로 카메라 위치를 제한했는데 이를 게임 시작 시 현재 카메라 Y값을 변수에 대입해 1대신에 사용
이럴 경우 후에 카메라의 위치가 바뀌어도 카메라의 위치값을 변수에 대입하기 때문에 코드를 건드리지 않아도 됨

originPos_CameraY = tf_Camera.localPosition.y;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 1 상호작용

1. 상호작용 가능한 객체 위에 마우스 울리면 UI 변하기
I. 상호작용 전용 여러 이미지를 겹치게 해서 UI Interactive_Corsshair 제작하기

2. 카메라에서 Ray발사하기 (IntreactionCortroller Script)
I. 게임 카메라 상에서의 마우스 포지션을 게임에서의 월드 포지션으로 바꾼 후 그 값을 이용하여 Ray를 쏴야 함
이를 구현하기 위해 Camera 클래스에 있는 함수인 SceenPointToRay()에 마우스 포지션 값(카메라가 보고있는 스크린의 점)을 넣어 ray를 반환함
이때 ray는 발사할 Ray의 시작점과 방향을 둘 다 Vector 값으로 가짐  ex) Origin : (1, 0, 3), Dir : (0.7, 0, 0.3)
if (Physics.Raycast(cam.ScreenPointToRay(mousePosition), out rayHit, 100))

ScreenPointToRay 관련 Unity Manual : https://docs.unity3d.com/kr/current/Manual/CameraRays.html
Physics.Raycast 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Physics.Raycast.html

II. 
ray가 맞은 오브젝트의 태그가 Interaction이면 Interactive_Corsshair를 아니면 Normal_Corsshair를 보여줌

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 2 상호작용 이펙트

1. 상호작용 파티클 이펙트 만들기
I. 목표 : 물음표 모양을 한 스프라이트 이미지를 던지는 형식의 이펙트를 연출할 것이므로 딱 한번만 파티클이 나와야 하고 나오는 파티클을 미리 준비한 스프라이트 이미지로 바꾸어야함

II. Emission의 Rate over Time (시간 경과에 따른 입자 방출 수)를 0으로 하고 Bursts (시작 시 방출하는 파티클)의 Count를 1로 함 그리고 파티클의 모양을 스프라이트로 하기 위해 Texture Sheet Animation의 Mode를 Grid에서 Sprites로 바꾼 후 미리 준비해둔 스프라이트를 넣음 그리고 Render에서 Material을 Default-ParticleSystem으로 설정해야 보라색 버그 입자가 아닌 스프라이트가 정상적으로 나옴

III. 그대로 날아가면 재미가 없기 때문에 회전하면서 날아가도록 Rotation over Lifetime에서 Separate Axes를 체크 후 회전 방향을 설정함

IV. 이펙트가 물체에 닿았을 때 터지는 이펙트 만들기
사이즈를 줄이고 StartSpeed를 빠르게 한 후 Bursts의 Count를 20으로 설정하고 사방으로 퍼지도록 Shape를 shpere로 Radius(입자가 뿜어져 나올 영역의 크기로 0에 가까울 수록 한 점에서 뿜어져 나옴)를 0에 가깝게 설정 후 Size over Lifetime을 이용해 입자가 점점 작아지게 설정하고 입자가 원이 아니라 선처럼 뻗어나가도록하게 하기 위해 Render에서 Render Mode를 Billboard에서 Stretched Billboard로 설정 후 Speed나 Length에 따라 찢어지는 정도를 설정 

2. 파티클 투척하기
I. 상호작용이 가능한 상태에서 좌클릭을 하면 파티클이 실행됨 if(Input.GetMouseButtonDown(0) && interactable)

II. 부드러운 움직임을 위해 Lerp(Vector3 start, Vector3 end, float t) 함수를 이용해 이동 (end - start)/ t 만큼 움직임 0.5f면 1 / 2만큼 움직임
상호작용하려는 물체와 충분히 가까워지면 HitEffect를 Play함

III. 오브젝트의 Pivot를 바꿔서 이펙트를 타겟의 transform.position을 기준으로 발사할 때 이미지의 상반신을 향하게끔 바꿈
pivot 변경하는 방법을 다룬 블로그 : https://mariageunit.blogspot.com/2019/07/unity-1.html

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 3 상호작용 이벤트

1. 상호작용 대화창 만들기
I. 대화내용이 나오는 대화창 UI와 상호작용하는 객체의 이름이 나오는 UI 2개를 만듬

II. 새로운 스크립트인 DialogueManager(싱글톤)를 만들어 상호작용 이펙트가 객체와 충돌한 시점에서 대화 관련 UI가 나오도록 함

III. UIManager(싱글톤) 스크립트를 새로 만들어 대화중에는 화살표와 크로스헤어 UI 숨기기 

IV. DialogueManager에 대화중인지를 나타내는 bool 변수 isTalking을 선언하고 대화 중에는 화면 이동과 상호작용(클릭)을 하지 못하도록 함

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 4 디테일 (Tooltip + 추가 연출)

1. 상호작용 가능한 객체에 크로스헤어를 갖다대면 툴팁과 이펙트 뜨게 하기
I. 툴팁 UI, 인터랙션 UI 각각에 맞는 이미지 넣어서 만들기

II. 새로운 스크립트인 InteractoinType 만든 후 어떤 유형의 상호작용 객체인지 판별하기 위한 변수 및 이름 변수 선언 (골드메탈 쯔꾸르 대화기능 구현할 isNpc같이 script로 타입을 구분)
만든 후 봉란 객체에게 스크립트 부여 후 변수 선언 후 상호작용 가능한 상태에서 툴팁 UI와 객체 이름 뜨게 하기

interactable은 상호작용가능 여부
obj_TargetNameBar.SetActive(interactable);
txt_TargetName.text = (interactable) ? rayHit.transform.GetComponent<InteractionType>().GetName() : "";

III. 상호작용 이펙트
크로스헤어 갖다대면 이펙트 나타나게 하기, 코루틴을 이용해 늘 하던 while을 이용해 투명도 값을 조절하는 연출 이용 이때 기존의 Set_InteractionUI(bool interactable) 함수는 업데이트에서 돌아가기 때문에 코루틴 중복실행으로 그대로 확장이 불가능 그렇기에 isContact 변수를 만들어 중복실행을 막음
if (isContact == interactable) return;  
isContact = interactable;

그리고 새로 안 사실인데 코루틴을 문자열로 이용할때도 인수 하나까지는 커버를 칠 수 있었음 StartCoroutine("Co_AppearInteractionImg", true); 이런 식으로 사용하면 인수 하나있는 코루틴까지는 편하게 
정지가 가능 여기서도 중복 실행 방지를 위해 코루틴 사용 전에 StopCoroutine()를 사용함

IV.마름모 이미지가 점점 커지면서 투명해지는 이펙트 만들기
Vector3.Set(float x, float y, float z) : Vector3 변수를 설정(Set)하는 함수 = 으로 선언하는거랑 비슷함
상호작용 가능한 객체에 크로스헤어를 올리고 있으며 대화중이 아닌 상태에서 계속 돌아가는 무한반복 코루틴 만들기
IEnumerator Co_InteractionEffect()
    {
        float delayTime = 0.02f;
        WaitForSeconds ws = new WaitForSeconds(delayTime);

        // 상호작용 가능한 객체에 크로스헤어를 올리고 있으며 대화중이 아닌 상태에서 계속 돌아가는 무한반복 코루틴
        while (interactable && !DialogueManager.instance.isTalking)
        {
            Color color = img_InteractionEffect.color;
            color.a = 0.5f;

            img_InteractionEffect.transform.localScale = new Vector3(1.3f, 1.3f, 1.3f);
            Vector3 img_Scale = img_InteractionEffect.transform.localScale;

            while(color.a > 0 && !DialogueManager.instance.isTalking && interactable)
            {
                color.a -= 0.01f;
                img_InteractionEffect.color = color;
                img_Scale.Set(img_Scale.x + delayTime, img_Scale.y + delayTime, img_Scale.z + delayTime);
                img_InteractionEffect.transform.localScale = img_Scale;
                yield return ws;
            }
            yield return null;
        }
    }

V. 대화 중에는 상호작용 UI 안보이게 예외처리하기

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 1 데이터 파싱 및 엑셀 관리 ** 존나 중요하며 존나 길고 존나 어렵고 존나 재밌는 파트 ** 이번 파트는 전체적인 흐름만 적고 디테일한건 주석처리함
방대한 양의 대사들을 유니티에서 관리하면 비효율적이기 때문에 대사들을 엑셀 파일에서 관리하고 ,로 구분하는 데이터 자료형인 CSV(Comma Split Value)로 파싱 후 유니티로 불러들여 대화 기능을 구현

대사 클래스 (Dialogue Script) -> 대사 이벤트 클래스 (Dialogue Script) -> 엑셀파일 파싱 클래스 (DialogueParser Script) -> 파싱된 데이터를 저장하는 데이터베이스 매니저 클래스 (DataBaseManager Script) 
-> 상호 작용 이벤트 클래스 (InteractionEvent Script) -> 상호작용 컨트롤러 (InteractionController Script)에서 사용

1. 엑셀 데이터를 담을 틀을 가진 커스텀 클래스 2개 제작 (Dialogue Script)
이름과 대사(배열) 변수를 가진 Dialogue 클래스 Dialogue를 배열로 가지고 있고 엑셀 파일의 몇 번째 줄부터 몇 번째 줄까지를 가져올지 정하는 Vector2 변수를 가지고 있는 DialogueEvent 클래스 선언 
이 스크립트는 MonoBehaviour을 상속받지 않으므로 오브젝트의 컴포넌트로 직접 넣을 수 없고 InteractionEvent에서 수정할 것이기 때문에 둘 다 [System.Serializable]를 선언해 인스펙터 창에서 수정 가능하게
만듬

2. 엑셀파일 파싱 클래스 제작 (DialogueParser Script)
줄과 열(,)을 기준으로 Split함수를 이용해 데이터를 나눠서 string[] 변수에 담고 반복문을 사용해 Dialogue Script의 변수를 형식에 맞게 선언 후 반환하는 함수 제작
엑셀 파일을 csv파일로 변환했을 때 visual studio를 통해서 csv파일을 열어서 빈 줄이 있는지 확인하기 비어있는 줄이 있으면 빈 줄을 가져오려고 해서 에러 뜸

3. 파싱된 데이터를 저장하는 데이터베이스 매니저 클래스 제작 (DataBaseManager Script)
줄에 매칭되는 Dialogue Script를 가지는 딕셔너리 변수 선언 후 2.에서 만든 함수를 통해 얻은 배열을 이용해 반복문을 이용해 변수에 값 대입 후 시작 행과 끝 행을 인자로 받아 받은 줄의 데이터들의 배열을 반환하는 함수 제작

4. 상호 작용 이벤트 클래스 제작 (InteractionEvent Script)
객체에 들어가는 실질적으로 데이터를 가지는 스크립트
[SerializeField] DialogueEvent dialogueEvent; 변수를 가지며 3.에서 만든 함수에 1.에서 선언한 Vector2 변수의 x, y 값을 형변환 후 대입해 원하는 데이터를 변수에 선언하는 함수 제작

5. 상호작용 컨트롤러 (InteractionController Script)에서 사용
이전 파트에서 제작한 이펙트가 터지는 순간에 다이로그 바가 뜨는 함수에 4.에서 만든 함수 사용부분 추가

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 2 대화 시스템 구현

1. 대화 기능 구현 (DialogueManager Script)
I. 대사 치환 
csv파일은 ,로 데이터를 구분하기 때문에 대사에 ,를 쓰지 못하고 대신 |을 사용했는데 Replace()함수를 사용해서 |를 ,로 치환하기
string.Replace(string oldValue, string newValue) : string 변수에 old변수가 포함되어 있으면 newValue로 치환해주는 함수

II. 대사 출력 
캐릭터 대화의 순서를 나타내는 talkIndex변수와 대사의 순서를 나타내는 contextCount변수 다음 대화로 넘어갈 수 있는지를 나타내는 isNext변수 선언 후 대화 기능 구현에 사용
Update()문에서 isNext && isTalking && 마우스 또는 키보드 입력 시 실행되는 Talk()함수 선언
대화 한번마다 contextCount++시키고  한 캐릭터가 가지는 대사의 길이와 같아지면 contextCount = 0으로 하고 talkIndex++ 후 다시 대사 시작 talkIndex가 Dialogue[] 의 길이를 넘기면 대화 종료
void Talk()
{
        isNext = false;
        txt_Dialogue.text = "";
        if (++contextCount >= dialogues[talkIndex].contexts.Length)
        {
            contextCount = 0;
            talkIndex++;
        }

        if (talkIndex < dialogues.Length) StartCoroutine(Co_TypeWriter());
        else EndTalk();
}

III. 대사 타이핑 효과 구현
코루틴을 이용하여 한글자씩 대사를 추가
IEnumerator Co_TypeWriter()
{
        Set_DialogueUI(true);
        txt_Name.text = dialogues[talkIndex].name;
        txt_Dialogue.text = "";

        string replaceText = dialogues[talkIndex].contexts[contextCount];
        replaceText = ReplaceText_ToComma(replaceText);
        for (int i = 0; i < replaceText.Length; i++)
        {
            txt_Dialogue.text += replaceText[i];
            yield return new WaitForSeconds(textDelayTime);
        }
        isNext = true;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 3 디테일 (글자색 변경 등등)

1. 글자색 변경 (DialogueManager Script)
I. 엑셀 파일에서 강조하고 싶은 부분 양 옆에 특수문자 넣기 ex) 내 이름은 ⓨ봉란ⓦ이야 잘 부탁해 (ⓨ : 노란색 ⓦ : 하얀색)

II.  코드에서 특수문자를 감지해 어떤 텍스트에 효과 줄지 선택하기
대사 출력 효과를 구현하면서 반복문에서 1글자씩 대사를 더했기 때문에 반복문 내에서 한글자씩 비교하면서 만약 특수문자면 관련 함수를 실행시킴

char effectChar = ' '; // 어떤 효과를 줄지 구분하는 문자
for (int i = 0; i < replaceText.Length; i++)
{
            if (Set_IsColorText(replaceText[i])) // 더할 텍스트가 특수문자라면
            {
                effectChar = replaceText[i];
                continue;
            }

            string addText = replaceText[i].ToString();
            txt_Dialogue.text += (effectChar != ' ' && effectChar != 'ⓦ') ? ColoringText(effectChar, addText) : addText;
            yield return new WaitForSeconds(textDelayTime);
}

III. HTML 태그로 text에 색깔 넣기

string ColoringText(char t_Effect, string affectText) // 받은 특수문자에 맞는 효과를 string 인자에 구현 후 return
{
        string returnText;
        switch (t_Effect)
        {
            case 'ⓨ':
                returnText = "<color=#FFFF00>" + affectText + "</color>";
                break;
        }
        return returnText;
}

HTML 태그는 텍스트 인스펙터 창에서는 드러나지만 실제 게임에서는 나오지 않고 텍스트에 관련 효과가 적용됨 HTML과 같이 <> 로 시작해 같은 태그의 </>로 닫히면 <b>(굵게 하기), <i>(글자 기울이기),
<Size=px>(크기) 등의 태그가 지원되며 텍스트의 메테리얼도 지정할 수 있음 ex) We are <material=2>texturally</material> amused (material=2는 메쉬의 메테리얼 배열의 인덱스 값)
또한 태그는 대소문자를 구분하지 않음 ex) <Size=10>Hi</Size>, <SIZE=10>Hi</SIZE>, <SIZE=10>Hi</SiZe> 모두 가능.

태그 관련 내용 Unity Manual : https://docs.unity3d.com/kr/530/Manual/StyledText.html

2. 줄바꿈하기
Unity에서 줄바꿈은 \n(escape문)이지만 엑셀에서의 \n은 텍스트이기 때문에 escape문으로 인식하기 위해 대체 
// \n 앞에 \(escape문)을 붙이면 뒤에 문자는 텍스트로 인식
replaceText = replaceText.Replace("\\n", "\n"); 

3. 나레이션 추가
나레이션은 이름이 없기 때문에 나레이션 중에는 NameBar숨기기
이름이 없는 것을 이용해 코드를 작성, 이름을 조건으로 넣었기 때문에 NameBar의 텍스트를 이 부분에서 작성해야함
if (dialogues[talkIndex].name == "") obj_NameBar.SetActive(false); 
else
{
            obj_NameBar.SetActive(true);
            txt_Name.text = dialogues[talkIndex].name;
}

II 색깔 강조
나레이션은 모든 대사 시안색으로 처리하기, 그냥 엑셀에서 나레이션 앞에 ⓒ붙이고 위에서 짠 코드에 추가하면 됨

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 5 - 1 카메라 타겟팅

1. 특정 트랜스폼에 카메라 타겟팅하기 (CameraController Script)
I. 조건 
타겟팅하려는 객체의 Transfrom을 받고 Coroutine을 사용하여 카메라가 조금씩 객체의 앞으로 카메라가 이동하며 객체를 바라보도록 회전는 기능 구현
이때 while의 조건에 포지션과 함께 두 방향 a, b 사이의 각도를 반환하는 Quaternion.Aagle(Quaternion a, Quaternion b)를 사용하여 각도가 어느정도 작아질 때까지 while을 돌림

while(transfrom.position != forwardTargerPosition || Quaternion.Aagle(transform.rotation, Quaternion.LookRotation(camDirection) ) >= 0.5f )
이때 Quaternion.LookRotation(Vector3 forward, Vector3, upwards = Vector3.up)은 오브젝트가 forward방향으로 회전했을 때의 rotation값을 나타내며 upwards = Vector3.up은머리가 향하는 방향을 나타내며 
생략 시 객체의 머리는 위를 향하게 된다 머리가 항상 위를 향하므로 y축만 계산한며 x, z의 rotation값은 0으로 나온다 결국 y축의 값만 얻을 수 있다.

unity Quaternion.Lookrotation Manual : https://docs.unity3d.com/kr/530/ScriptReference/Quaternion.LookRotation.html
Quaternion.Lookrotation 관련 블로그 : https://blog.naver.com/PostView.nhn?blogId=happybaby56&logNo=221324341865

unity Quaternion.Angle Manual : https://docs.unity3d.com/kr/530/ScriptReference/Quaternion.Angle.html

II 이동 및 회전
코루틴의 대기와 현재 위치에서 목표지점까지 지정한 값만큼 움직이는 Vector3.MoveTowards(Vector3 currnet, Vector3 target, float maxDistanceDelta) 를 이용하여 카메라를 이동시킨다
회전은 Quaternion.Lerp()함수를 이용해 이동시킨다.

IEnumerator Co_CameraTargetting(Transform p_Targer, float p_CameraSpeed = 0.05f)
{
        Vector3 targetPosition = p_Targer.position;
        Vector3 forwardTargerPosition = targetPosition + p_Targer.forward * 1.5f;
        Vector3 camDirection = (targetPosition - forwardTargerPosition).normalized;

        while (transform.position != forwardTargerPosition || Quaternion.Angle(transform.rotation, Quaternion.LookRotation(camDirection) ) >= 0.5f )
        {
            transform.position = Vector3.MoveTowards(transform.position, forwardTargerPosition, p_CameraSpeed);
            transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(camDirection), p_CameraSpeed);
            yield return null;
        }
}

unity Vector3.MoveTowards Manual : https://docs.unity3d.com/kr/530/ScriptReference/Vector3.MoveTowards.html

III. 코루틴 충돌
코루틴 충돌을 방지해 코루틴을 멈춰야 하는데 인자가 2개이므로 문자열 방식으로 멈추지 못하기 때문에 StopAllCoroutine()을 사용한다. StopAllCoroutine()은 사용한 스크립트 내의 코루틴만 멈추기 때문에
여기에서는  Co_CameraTargetting()외에 다른 코루틴을 멈추지 않는다.

2. 코루틴 사용
** 강의에서는 객체의 Transfrom 변수를 인스펙터 창에서 일일히 선언하였는데 나는 만약 1000번의 대화를 만든다고 하면 이건 말도 안되는 노가다라고 생각해 다른 방식으로 구현하기를 원했고 결국 해냈다. **

I. 씬에 있는 모든 대화 객체의 이름을 key로 Transform을 value로 가지는 딕셔너리 (CharacterManager Script)
강의에서는 엑셀 파일에 대화하는 주체의 이름을 작성했기 때문에 나는 "그냥 이름하고 Transform하고 매치시키면 안되나?"라고 생각했고 이럴 때 딕셔너리만한 자료구조가 없다.
하지만 내 생각대로 하려면 게임 시작 전에 딕셔너리 안에 Transform 변수를 담기 위해 인스펙터 창에 딕셔너리를 표시해야하는데 unity에서는 이를 지원하지 않았고 결국 유튜브 영상을 보고 구현했다.
인스펙터 창에 딕셔너리 표시하는 방법 : https://www.youtube.com/watch?v=sivvCb5AERc (그냥 에셋 임포트해서 사용하는 영상)

II. Dialogue의 tf_Target 변수 DialogueEvent에 엑셀 파일 채우면서 같이 채우기 (InteractionEvent Script)
Dialogue는 대사를 치는 캐릭터를 기준으로 개수가 정해지므로 DialogueEvent의 Dialogue[] dialogues; 의 길이만큼 반복문을 돌리고 Dialogue의 tf_Target 변수를 선언했다.

for(int i = 0; i < dialogueEvent.dialogues.Length; i++) // tf_Target 대입
{
            Dialogue dialogue = dialogueEvent.dialogues[i]
            dialogue.tf_Target = CharacterManager.instance.dic_Character[dialogue.name];

            dialogueEvent.dialogues[i] = dialogue;
}

III. 예외처리
주인공이 말할 경우나 나레이션은 Dictionary에서 찾지 못하는 에러와 카메라가 타겟팅할 객체가 null이 되는 에러가 생긴다 특히 딕셔너리 관련 에러는 스크립트가 멈추기 때문에 꽤나 심각한 버그다
이를 위해 Dictionary에 name "주인공" 이거나 ""경우에 null을 넣어 타겟팅 객체에 null값을 주도록 하고 만약 객체의 값이 null이거나 이전과 같은 객체라면 카메라 타겟팅을 하지 않도록 한다.

IV. 타겟팅을 하고싶지 않을때
이 코드는 대사를 치는 캐릭터에게 '무조건' 카메라가 타겟팅하게 되어있다. 만약 인스펙터 창에서 채웠으면 사람이 임의로 정할 수 있었겠지만 Script로 채우는 것이기 때문에 그렇게 할 수 없다.
그래서 타겟팅하지 않을 캐릭터의 이름에는 엑셀 파일의 이름앞에 ⒳를 붙이고 이를 코드에서 감지하여 ⒳를 ""로 바꾸고 tf_Target에 null값을 주도록 하였다.
for(int i = 0; i < dialogueEvent.dialogues.Length; i++)
{
            Dialogue dialogue = dialogueEvent.dialogues[i];

            // 이름 앞에 ⒳가 붙어 있으면 타겟팅 안하는거임
            if (dialogue.name[0] != '⒳') dialogue.tf_Target = CharacterManager.instance.dic_Character[dialogue.name];
            dialogueEvent.dialogues[i] = dialogue;
}

또한 NameBar에 이름이 그대로 가지 않게 하기위해 이름 설정 부분을 수정한다.

if (name[0] == '⒳') name = name.Replace("⒳", "");
txt_Name.text = name;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 5 - 2 카메라 리셋

1. 카메라 리셋하기 (CameraController Script)
I. 목표 : 대화가 끝나면 대화를 시작하기 전의 위치로 돌아오고 각도는 (0, 0, 0) 으로 돌리기

II. 제작 및 사용 
대화 전 위치와 각도를 담을 변수를 만들고 대화가 시작할 때 카메라의 위치를 기억하는 함수를 만들고 대화가 시작할 때 실행
Part 5 - 1와 비슷한 형식으로 원본 위치로 돌아가는 코루틴을 만들고 대화가 끝날 때 실행

2. 디버깅 및 디테일
I. 각도 버그
카메라를 리셋하고 나면 갑자기 카메라 각도가 바뀌는데 이는 PlayerController에서 전에 있던 앵글 변수값을 각도에 적용해서 생기는 버그 그렇기에 관련 변수를 0으로 만드는 함수를 만들고 카메라 리셋하기 전에 사용

II UI 디테일
대화가 끝나자마자 바로 UI가 켜지는데 부자연스럽기 때문에 카메라 리셋이 끝나고 UI가 켜지게 하기 위해 카메라 리셋 마지막 부분에 UI켜지게 하기

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 5 - 3 디테일 (세부 조정)
1. 카메라 리셋이 중복하게 일어날 때 ** 나는 코드를 다르게 짜서 문제가 일어나지 않지만 해결 방법이 알아두면 좋을 것 같아서 적음 **
현재 코드는 AllStopCoroutine()을 사용하므로 카메라 리셋이 중복되서 일어날 경우 카메라 리셋 시작할 때 실행되는 대기 코드 때문에 카메라 무빙이 끊기는 듯한 모습을 보여줌
이를 해결하기 위해 Coroutine 변수를 선언하여 카메라 타겟팅을 넣고 변수가 카메라를 리셋할 때 null이 아니면 카메라 타겟팅 코루틴을 멈추고 카메라 리셋 실행 이러면 카메라 리셋은 멈추지 않으므로 끊기는 듯한 연출을 없어짐 (나는 카메라 리셋 코루틴이 중복 실행되는걸 방지해서 카메라 리셋이 실행중이 아닐때만 카메라가 리셋하는 코드도 추가할 듯)

2. 네임바가 없어지지 않는 버그 (난 마지막에 알아서 꺼져서 버그 없음)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 6 - 1 스프라이트 교체

1. 액셀 파싱
엑셀 파일의 행(row)을 추가하여 스프라이트가 바뀌기를 원하는 지점에 스프라이트의 이름을 복사해서 붙여넣고 Dialogue Script에 string[] 형식의 변수를 선언하고 DialogueParser에서 파싱한 부분해 대사와 똑같은 형식으로  대입함 (캐릭터가 한번에 대화할 때 여러 번 스프라이트를 바꿀수도 있기 때문에 배열로 선언)

2. 스프라이트 교체 (SpriteManager Script) 
현재 캐릭터스프라이트는 콜라이더나 스크립트를 가지고 있는 빈 객체에 자식 개체로 있기 때문에 GetComponentInChildren<SpriteRenderer>(); 을 통해 스프라이트 렌더러를 가져오고 스프라이트 교체 시 적용시키고자 하는 스프라이트는 Loda("Characters/" + spriteName) 을 통해 스프라이트에 접근하고 as Sprite를 통해 파일을 스프라이트로 변환해줌 이때 가져온 파일이 스프라이트 파일이 아니라 변환이 불가능하면 null값이 들어가는데 이러면 오류가 생길수도 있고 하니 typeof(Sprite)를 통해 타입이 같은지 확인함

SpriteRenderer sr = targer.GetComponentInChildren<SpriteRenderer>();
spriteName = spriteName.Trim(); // 원인은 모르겠지만 글자 마지막에 공백이 들어가서 공백 지우는 함수 사용
Sprite sprite = Resources.Load("Characters/" + spriteName, typeof(Sprite)) as Sprite;

이때 가져온 스프라이트가 현재 캐릭터가 보여주고 있는 스프라이트가 아니거가 null 값도 아니라면 스프라이트렌더러의 스프라이트를 교체
sr.sprite = sprite;
교체 후에 투명도 값을 올리는 효과도 구현했지만 늘 보는 코루틴 공식이므로 생략

3. 디버그
일단 스프라이트 이름 마지막에 공백이 들어가는 버그도 있었지만 위 코드에서 주석처리로 언급했기 때문에 넘어가고 일단 나는 기본적으로 강의에서 사용하는 코드랑 방향성이 달라서 내가 직접 인스펙터 창에서 세부적인걸 조정하지 않고 다 자동으로 설정하게 했는데 이러면 주인공이 말하거나 독백할 때 tf_target 변수가 null이기 때문에 주인공이 말하고 있거나 마지막 대사를 한 후 대화가 끝나서 스프라이트를 초기화시킬 때 문제가 생긴다 때문에 tf_Target 변수의 의미를 카메라가 타겟팅하려는 캐릭터가 아니라 현재 대화 중인 캐릭터로 의미를 확장시켜 위에서 말한 문제점을 고쳤고 이로 인해 후에 캐릭터와 관련하여 어떠한 기능을 추가할 때 더 쉽게 확장할 수 있을 것이다.
// target은 현재 대화 상대를 의미 주인공이 말하거나 독백할때도 target에는 대화상대가 들어감
Transform currentTarget = null;
if (dialogue.tf_Target == null) dialogue.tf_Target = currentTarget;
else currentTarget = CharacterManager.instance.dic_Character[dialogue.name];

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 6 - 2 디테일 (뒷모습과 회전)

1. 캐릭터 뒷모습
I. 캐릭터 부모 오브젝트에 스프라이트 오브젝트를 복사하고 포지션을 약간 뒤로 옮긴 후 색깔을 검정색으로 해서 뒤에서 보면 아예 검은색으로 보이도록 함

II. 기존에 스프라이트 교체 시 투명도를 조금씩 더하는 연출을 구현했는데 뒤에 검은색이 보이면 부자연스럽기 때문에 SpriteRenderer을 GetComponentsInChildren<>으로 배열로 가져온 후에 0번째에 스프라이트가 1번째에 그림자가 오도록 해서 그림자에도 똑같이 스프라이트를 바꾸고 투명도를 높이는 연출을 적용시킴

2. 캐릭터 플레이어 바라보기 (CharacterSpin Script)
I. 캐릭터를 바라볼 때 회전값을 가지는 Quaternion 변수와 transform.eulerAngles에 대입할 Vector3변수를 선언 후 y축의 회전값만 바뀌어야하기 때문에 회전값에서 y값만 Vector변수에 전달 후 회전값 변경
void Update()
{
        lookAngle = Quaternion.LookRotation(tf_Target.position);
        lookEuler = Vector3.up * lookAngle.eulerAngles.y;
        transform.eulerAngles = lookEuler;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 7 페이드 인 아웃

1. enum 타입 덮어쓰기 (InteractionEvent Script)
원래는 카메라 리셋 강의에서 했던건데 나는 그때 코드를 다르게 짜서 안했었음 근데 이번에는 아무레도 따라하는게 편할 것 같아서 따라함
인스펙터 창에서 선언해둔 변수를 적용하기 위해 다른 instanceDialogue를 인스턴스해서 만들고 거기에 엑셀 데이터를 대입 후 인스펙터에 있는 원본 DialogueEvent 클래스의 정보를 대입하고
원본에 제작한 DialogueEvent를 대입함 카메라 관련 연출이 있을때만 후에 다른 기능이 추가된다해도 "인스펙터 창에서 선언이 필요할 때만" 인스펙터 창을 선언하고 나머지는 자동으로 할꺼기 떄문에
원본의 크기가 엑셀 데이터를 파싱받은 instanceDialogues의 정보를 받을 공간이 있을때만 덮어쓰기를 함

public void SetDialogueEvent()
{
        DialogueEvent instanceDialogues = new DialogueEvent();
        instanceDialogues.dialogues = new Dialogue[(int)dialogueEvent.line.y - (int)dialogueEvent.line.x + 1]; // dialogues의 크기 결정 (크기는 dialogueEvent에서 결정)
        instanceDialogues.dialogues = DataBaseManager.instance.GetDialogues((int)dialogueEvent.line.x, (int)dialogueEvent.line.y); // dialogues 선언

        for (int i = 0; i < instanceDialogues.dialogues.Length; i++) // 각종 변수 대입
        {
            Dialogue dialogue = instanceDialogues.dialogues[i];

            // 이름 앞에 ⒳가 붙어 있으면 타겟팅 안하는거임 
            if (dialogue.name[0] != '⒳') dialogue.tf_Target = CharacterManager.instance.dic_Character[dialogue.name];

            // target은 현재 대화 상대를 의미 주인공이 말하거나 독백할때도 target에는 대화상대가 들어감
            if (dialogue.tf_Target == null) dialogue.tf_Target = currentTarget;
            else currentTarget = dialogue.tf_Target;

            if (dialogueEvent.dialogues.Length > i) // 인스펙처 장에서 선언한 dialogueEvent 덮어쓰기용
            {
                dialogue.cameraType = dialogueEvent.dialogues[i].cameraType;
            }
        }
        // 선언 후 반환
        dialogueEvent.dialogues = instanceDialogues.dialogues;
}

2. 카메라 fade 연출 (FlashManager Script)
I. fade 연출 구현
인수로 bool 값을 받아 white인지 black 이미지인지 구분 좀 재밌었던 부분은 image로 구현을 다르게 하는게 아니라 하얀색 이미지 하나에 color 변수 2개를 만들고 하나는 하얀색 하나는 검은색을 대입하고 bool인자값에 따라 이미지에 color를 넣어 구현을 했다는거, 그리고 늘 하던 코루틴 while문으로 투명도 구현
public void FadeOut(bool isWhite, bool isSpeed = false)
{
        Color color = isWhite ? whiteColor : blackColor;
        float speed = isSpeed ? fadeSlowSpeed : fadeSpeed;
        StartCoroutine(Co_FadeOut(color, speed));
}

IEnumerator Co_FadeOut(Color color, float speed)
{
        isFade = true;
        color.a = 0;
        fadeImage.color = color;

        while(color.a < 1)
        {
            color.a += speed;
            fadeImage.color = color;
            yield return ws;
        }
        isFade = false;
}

II. fade 연출 구분 (DialogueManager Script)
swich문을 사용해 타입마다 다른 함수 실행 후 대화 관련 UI를 끄고 fade 연출이 끝날 때까지 대기한 후 다시 대화 시작하는 함수 구현
IEnumerator Co_FadeCamera(CameraType cameraType)
{
        switch (cameraType)
        {
            case CameraType.FadeIn: splashManager.FadeIn(false); break;
            case CameraType.FadeOut: splashManager.FadeOut(false); break;
            case CameraType.FlashIn: splashManager.FadeIn(true); break;
            case CameraType.FlashOut: splashManager.FadeOut(true); break;
        }
        Set_DialogueUI(false);
        yield return new WaitUntil(() => !splashManager.isFade);
        StartCoroutine(Co_TypeWriter());
}

III. fade연출 사용 (DialogueManager Script)
CameraType이 Default면 카메라 타겟팅을 실행하고 아니면 fade연출 실행 또한 화자가 바뀔 때 대화를 끝날 건지 계속할건지 결정하도록 Talk() 함수를 수정
void Talk()
{
        isNext = false;
        txt_Dialogue.text = "";
        if (++contextCount >= dialogues[talkIndex].contexts.Length) // 대화의 화자가 바뀔 때
        {
            contextCount = 0;
            if (++talkIndex < dialogues.Length) // 각종 카메라 연출
            {
                if (dialogues[talkIndex].cameraType == CameraType.Default) StartCoroutine(Co_CameraTargetTing());
                else StartCoroutine(Co_FadeCamera(dialogues[talkIndex].cameraType));
            }
            else EndTalk(); // 화자가 바뀔때만 talkIndex가 오르기 때문에 여기서 대화 종료 여부 결정
            return;
        }
        // 똑같은 화자가 2번 이상 말할 때 별도의 조건 없이 그냥 대사 출력
        StartCoroutine(Co_TypeWriter());
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 8 사운드 매니저 + 강조 연출

1. SoundManager Script 작성
I. Sound class
이름(string)과 오디오 클립을 가지고 있는 Sound class 선언

II. 브금, 효과음, 보이스 재생 함수
각각의 음향을 담당하는 AudioSource 선언 후 미리 만들어둔 Sound를 배열로 선언 필요에 따라 배열로 선언
브금의 이름을 인자값으로 받고 반복문을 돌려 이름과 일치하는 브금이 있으면 재생 없으면 경고문 출력
void PlayEffectSound(string p_Name)
{
        for (int i = 0; i < effectSounds.Length; i++)
        {
            if (p_Name == effectSounds[i].name)
            { 
                effectPlayer.PlayOneShot(effectSounds[i].clip);
                return;
            }
        }
        Debug.LogWarning("찾을 수 없는 효과음 이름 : " + p_Name);
}

AudioSource는 Stop으로 멈출 수 있으며 PlayOneShot()으로 실행한 클립도 멈출 수 있지만 2개 이상의 오디오가 같이 나올때 2개다 멈춰버리기 때문에 bgm과 효과음같이 종류가 다른 클립은 오디어소스를 서로 구분하는게 좋음 Pause()랑 UnPause()도 비슷하게 작동하는듯

보이스는 Sound클래스로 이름을 선언하지 않고 파일 이름으로 찾음
AudioClip  _clip = Resources.Load<AudioClip>("Sounds/Voice/" + p_Name);  없으면 경고문

함수 위에 /// 하면 설명 넣을 수 있음 알아서 자동완성되는데 <summary> 태그 안이 설명

2. 엑셀 파일 추가
I. 효과음
효과음은 대사 맨 앞에 ①처럼 숫자 형식의 특수문자를 넣어서 조건에 따라 이름에 숫자를 더한 후 인자값에 사용
string name = "Emotion";
switch (number)
{
            case '①': name += "1" ; break;
            case '②': name += "2" ; break;
            case '③': name += "3" ; break;
            case '④': name += "4" ; break;
            case '⑤': name += "5" ; break;
}

II. 보이스
보이스는 엑셀파일에 행을 추가해서 Dialogue에 추가로 string[]을 선언해서 파일에 있는 이름을 그대로 인자값에 사용

3. 사운드 매니저 사용
I. 보이스
함수 생성 후 대화 시작 시 사용
void PlayVoice()
{
        string _voiceName = dialogues[talkIndex].voiceNames[contextCount].Trim(); // Trim()은 감지가 안되는 " " 가 존재하는오류 때문에 사용
        if (_voiceName != "") SoundManager.instance.PlaySound(_voiceName, 2);
}

II. 효과음
텍스트를 더할지 더하지 않을지 정하는 bool Set_IsColorText() 함수에서 조건을 추가해서 감지
bool Set_IsColorText(char char_Context) // 받은 인자가 특수문자면 true 아니면 false return
{
        switch (char_Context)
        {
            case 'ⓦ':
            case 'ⓨ':
            case 'ⓒ':
                return true;
            case '①': // 여기부분 코드 바꾸기
            case '②':
            case '③':
            case '④':
            case '⑤':
                SoundManager.instance.PlaySound(ReturnSoundEffectName(char_Context), 1); // 특수기호에 맞는 숫자를 더해서 함수 인자값에 사용할 이름완성
                splashManager.Splash();
                return false;
            default:
                return false;
        }
}

III. 빛 반짝이는 효과
SplashManager에서 기존에 만들었던 코루틴을 기반으로 코루틴으로 빛 반짝이는 연출 구현
IEnumerator Co_Splash()
{
        isFade = true;
        FadeOut(true);
        yield return new WaitUntil(() => !isFade); // isFade는 Fade관련 코루틴 실행중에 true
        FadeIn(true);
}

후에 효과음 실행할때 같이 실행

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 9 - 1 컷씬 연출

1. 엑셀 파싱 및 Dialogue에 카메라 Type추가
엑셀 파일에 새로운 행을 만들고 그 행의 정보를 담는 배열을 Dialogue에 선언 후 Dialogue의 카메라 타입에 ShowCutScene, HideCutScene 추가

2. CutSceneManager 작성
인자값으로 컷씬 이름과 보여줄지 숨길지 여부를 정하는 bool변수를 받고 보여준다면 image의 스프라이트 할당후 컷씬 보여주가 아니라면 컷씬 숨기고 함수 종료

public void CutScene(string cutSceneName, bool isFinish)
{
        isCutScene = true;
        if (isFinish)
        {
            StartCoroutine(Co_CutScene(false));
            return;
        }

        Sprite _sprite = Resources.Load<Sprite>("CutScenes/" + cutSceneName);
        if (_sprite != null) cutSceneImage.sprite = _sprite;
        else Debug.LogWarning("찾을 수 없는 컷씬 이름 : " + cutSceneName);

        StartCoroutine(Co_CutScene(true));
}

IEnumerator Co_CutScene(bool isShow)
{
        splashManager.FadeOut(true);
        yield return new WaitUntil(() => !splashManager.isFade);

        cutSceneImage.gameObject.SetActive(isShow);

        splashManager.FadeIn(true);
        yield return new WaitUntil(() => !splashManager.isFade); // 연출을 위한 대기

        yield return new WaitForSeconds(0.5f);
        isCutScene = false;
}

3. CutSceneManager 사용
현재 대화중인 차례의 CutSceneName이 비어있지 않다면 실행
if (dialogues[talkIndex].cutSceneName[contextCount].Trim() != "") StartCoroutine(Co_CameraCutScene(dialogues[talkIndex].cameraType));

카메라 타입에 따라 컷씬 숨기거나 보여주기
IEnumerator Co_CameraCutScene(CameraType cameraType)
{
        string cutName = dialogues[talkIndex].cutSceneName[contextCount].Trim();
        switch (cameraType)
        {
            case CameraType.ShowCutScene: cutSceneManager.CutScene(cutName, false); break;
            case CameraType.HideCutScene: cutSceneManager.CutScene("", true); break;
        }

        Set_DialogueUI(false);
        yield return new WaitUntil(() => !cutSceneManager.isCutScene);
        StartCoroutine(Co_TypeWriter());
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

내 파트 - 리펙토링

1. 여러가지 함수, 변수명 변경

2. event를 사용해 대화 시작 후 연출 코드들의 견고한 커플링 해소
원래는 스크립트마다 각각의 함수를 만들고 DialogueManager에 그 함수를 사용하는 함수를 또 만들고 대화 시작 후에 함수를 다 때려박는 식이었는데 이 연출은 엑셀파일에 의존하기 때문에 string인자값이 굉장히 중요한데 원하는 엑셀파일에 접근하기 위해서는 현재 대화중인 dialogue와 contextCount 변수가 필요하기 때문에 <Dialogue, int> 인자값을 가지는 Action event인 AfterTalkEffect를 선언 후 각각의 스크립트에서 원하는 연출을 구현하는 함수를 더하는 식으로 코드를 바꿔서 DialogueManager와 다른 스크립트들이 과도하게 엮이거나 DialogueManager에서 다른 스크립트에서 구현해야할 연출을 구현해야하는 상황 방지 
public event Action<Dialogue, int> AfterTalkEffect; (DialogueManager Script)
void PlayVoice_byTalk(Dialogue dialogue, int contextCount) (SoundManager Script)
{
        string _voiceName = dialogue.voiceNames[contextCount].Trim(); // Trim()은 감지가 안되는 " " 가 존재하는오류 때문에 사용
        if (_voiceName != "") PlayVoiceSound(_voiceName);
}

3. 대화 전에 실행되는 카메라 연출도 2번처럼 하려고 했는데 코루틴 종료 시점에 맞춰서 대화를 시작하는 부분이 event를 이용하기 애매해서 때려침

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 9 - 2 디테일
9 - 1에서 구현한 방식은 대화가 시작하기 전에 컷씬을 연출하는 방식이기 때문에 마지막 대화에서도 컷씬을 보여주고 싶다면 EndTalk()에서 꺼야함 따라서 EndTalk에서 CutScene이 진행되고 있는지 확인 후 진행중이라면 컷씬을 끔 이때 컷씬이 끝날때까지 대기해야하기 때문에 코루틴 사용

// 현재 컷씬 진행중인지 확인하는 프로퍼티 변수
public bool chectCutScene {get { return cutSceneImage.gameObject.activeSelf; } } ( gameObject.activeSelf를 사용해서 현재 게임오브젝트가 활성화중인지 아닌지 bool변수로 확인가능 )

IEnumerator EndTalk()
{
        if (cutSceneManager.ChectCutScene)
        {
            cutSceneManager.CutScene("", true);
            Set_DialogueUI(false);
            yield return new WaitUntil(() => !cutSceneManager.isCutSceneEffect);
        }
        // 나머지 코드	
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 10 슬라이드 CG 연출

1. 애니메이션 제작
I. 슬라이더 전용 UI 이미지를 만든 후 이미지에 애니매이션 제작 
II. ** 제작할 때 빨간색 녹화 버튼을 누르고 원하는 프레임 설정하고 인스팩터 창에서 편집하면(스프라이트 교체, transform 설정) 알아서 애니애이션이 생성됨 ** ( 직접 해보면 간단한 애니매이션 만들 때 레알 개꿀임 )

2. 데이터 설정
슬라이더와 컷씬이 겹칠일은 없기 때문에 그냥 엑셀 파일에서 컷씬과 같은 행을 공유함 그리고 Diaolgue에 카메라 타입을 추가함

3. SlideManager 작성
I. 슬라이더에 원하는 이미지 스프라이트를 부여하고 Appear 애니메이션을 실행시키는 함수와 슬라이더를 숨기는 애니메이션을 실행하는 함수와 슬라이더를 숨기고 스프라이트 바꾼 후 다시 Appear 애니메이션을 실행하는 기능 구현 이때 애니메이터를 이용하지 않고 animation.Play(animation 이름)를 사용 이 방법은 애니메이터 SetTrigger() 같은 느낌으로 사용되는데 지금처럼 간단하게 1~2개의 애니메이션만 있는 경우 간단히 코드로 구현할 수 있기 때문에 animator를 사용하는 것보다 훨씬 편함 이때 애니메이션을 사용하려면 사용하려는 animation의 'Legacy'를 체크해야하는데 이는 애니메이션 클릭 후 인스펙터 우클릭 후 Debug를 클릭해야 보임

Animation Unity Manual : https://docs.unity3d.com/ScriptReference/Animation.Play.html

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

내 파트 - 엑셀 파일 추가 및 리펙토링

1. 엑셀파일 추가
이유는 모르겠지만 CSV 파일은 엑셀 파일과 달리 행 길이가 저장이 안되서 작업할 때 불편함 그래서 CSV와 같은 이름의 엑셀 파일을  추가한 후 대사 작업을 엑셀 파일에서 한 후 다른 이름으로 저장한 -> CSV로 저장 후 덮어쓰기하면 엑셀파일에서 작업 가능 

2. 이벤트 리펙토링
지난번에 대화 전에 실행되는 카메라 연출은 코루틴 대기가 필요해서 event를 이용하기 애매해서 리펙토링을 안하고 냅뒀는데 DialogueManager에 bool isCameraEffect 변수를 추가해서 카메라 관련 연출을 진행하는 동안은 저변수를 true설정하게 해 코루틴 대기를 통합해서 사용할 수 있게하고  지금까지 사용하던 스위치문을 기반으로 한 함수들을 각각의 스크립트에 옮기고 BeforeTalkEvent event를 구독하게 함 이것이 오류 없이 돌아가는 이유는 카메라 연출이 enum type을 조건으로 실행되기 때문에 한번에 하나의 연출만 실행되는게 보장되기 때문 따라서 각각의 스크립트에서 BeforeTalkEvent event를 구독할 때마다 조건을 하나씩 추가하는 형식의 event가 됨

IEnumerator Co_BeforeTalkEvent(Dialogue dialogue, int contextCount)
{
        if(BeforeTalkEvent != null) BeforeTalkEvent(dialogue, contextCount);
        Set_DialogueUI(false);
        yield return new WaitUntil(() => !isCameraEffect);
        StartCoroutine(Co_TypeWriter());
}

이렇게 함으로써 기존에 다른 스크립트의 기능을 사용하기 위해 DialogueManager와 다른 스크립트들의 견고한 커플링을 해소함
 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 11 캐릭터 등장 및 퇴장
[Space] : 인스펙터 창에 여백을 줌

1. 캐릭터 등장 및 퇴장
강의에서의 구현 방법은 기존의 InteractionEvent에 추가로 타입을 넘기고 그 타입에 맞는 이벤트 함수를 DialogueManager에서 생성하고 InteractonController에서 타입을 검사해 조건문을 써서 조건에 맞는 함수를 사용하는 방식인데 역시 마음에 들지 않아서 새로운 스크립트인 EventManager에서 각종 이벤트를 구현 및 event를 선언하고 EventByTalk에서는 타입만 검사하고 DialogueManager에 새로운 event를 만들고 EventByTalk를 인수로 받음 event를 새로 만든 이유는 오브젝트가 EventByTalk가 있을때만 작동을 해야하기 때문에 조건문을 사용해서 OnEndTalk event와 조건분기를 다르게 하기 위해서임 나중에 이벤트가 많아지면 인터페이스를 써서 기능을 구현할 수도 있음

2. 캐릭터 등장효과
단간론파는 캐릭터가 누워있다가 일어나는데 여기서는 회전하면서 투명도 올라가면서 등장 투명도는 늘 한던 코루틴 while문이고 회전은 딱 원점으로 돌아왔을때 플레이어를 바라봤으면 해서 코루틴에서 1초에 회전하는 값에 대기시킬 값을 나누고 그 값만큼 대기시키고 그 값을 변수에 더하다가 1이 넘으면 count역할을 하는 변수를 더하고 이게 3이넘으면 멈춤

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 12 자동 이벤트, Part 13 연속 이벤트 호출 (두개의 강의가 연결되는 부분이 있어서 그냥 한번에 함)

1. 자동 이벤트
I. 우선 강의에서 말하는 자동 이벤트는 상호작용 없이 자동으로 진행되는 이벤트를 말함 아마 맵 이동 후 진행되는 대화 등에 쓰일듯 기존에 InteracrtionEvent 스크립트에서 기능을 확장하는데 역시 맘에 안들어서 스크립트를 새로 만듬 하지만 강의에서 빈 오브젝트에 스크립트를 넣고 이벤트 진행 후 스크립트를 비활성화시키는건 보기가 편해서 좋은 방법이라고 생각해 그대로 따라함 순서는 DataManager에서 엑셀 파싱이 끝날 때까지 대기 후 0.5초 대기 후 대화 실행하는 코루틴을 오브젝트가 켜져있을 때 실행하기 위해 OnEnable()에서 실행
IEnumerator Co_Autotalk()
{
        yield return new WaitUntil(() => talkEvent.isSetDialogeu);
        yield return new WaitForSeconds(0.5f);
        DialogueManager.instance.StartTalk(talkEvent.GetDialogues());
        DialogueManager.instance.SetEvent(transform);
        yield return new WaitUntil(() => !DialogueManager.instance.isTalking);
        gameObject.SetActive(false);
}

2. 연속 자동 이벤트
I. 캐릭터의 등장이나 퇴장 등 여러 이벤트를 기준으로 대화가 잠시 멈췄다가 다시 다음 대화를 실행하는 연속 이벤트 구현
이벤트가 끝난 후 자신의 오브젝트를 비활성화 시키면서 다음 이벤트 오브젝트 활성화시키기 그럼 1에서처럼 이벤트가 실행됨

II. 자동 이벤트 대기
이벤트 사이사이에 UI가 뜬다던가 하는 부자연스러운 상황이 발생하기 때문에 EventManager에 자동 이벤트 중에 true인 isAutoEvent선언 false때만 UI 보여주게 하기 또한 enum타입의 AtuoEventType을 선언 후LastEvent일 때 isAutoEvent false로 되돌리기 상호작용이 가능한 문제도 해결하기 위해 isAutoEvent가 true일 때는 상호작용 막음

III. event대기
자동 이벤트 사이사이에는 캐릭터 등장 등 여러 이벤트가 있을 건데 그러한 이벤트를 대기하기 위해 EventManager 이벤트 진행중에 true isEvent를 만들고 false가 될때까지 대기 후 자동 이벤트 실행

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 14 - 1 맵 이동
상호작용 기능은 기존에 만들어 뒀기 때문에 문에다가 isDoor true체크하고 InteractionDoor Script 만든 후 넘어갈 씬 이름과 장소 이름 반환하는 함수 만들고 InteractionController에서 사용
맵 이동은 SceneLoad로 이동 이동 시 플레이어가 파괴되기 때문에 player 오브젝트 DontDestory()하고 다시 넘어올 때 플레이 오브젝트가 2개 있기 때문에 싱글톤으로 하고 싱글톤이 채워져있으면 플레이어 오브젝트 파괴 추가로 UIManager와 DialogueManager와 같은 하나만 있고 게임내내 필요한 오브젝트도 DontDestory()선언

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 14 - 2 스폰 위치 설정

1. 스폰 위치 설정 (ScenePositionManaager Script)
스폰할 위치를 가지는 빈 게임 오브젝트 생성 후 적절한 위치에 배치(잘 보이게 마크 설정)  -> 장소 이름과 트랜스폼을 가지는 커스텀 클래스 Locaiton 생성 후 인스팩터 창에 배열로 띄움(한 맵에 스폰할 수 있는 위치의 개수만큼 Location[]의 크기 설정) -> Location의 정보를 가지고 Dictionary<string, Transform> 형식의 딕셔너리 선언 -> FindObjectType으로 SceneTransferManager를 찾아서 LocationName을 가져오고
Start()에서 실행 -> Start에서 실행하기 때문에 게임을 처음 시작할 때와 같이 원하지 않을 때 실행되지 않을 수 있기 때문에 bool spawn_able변수를 만들고 true일 때만 리스폰 실행(true로 선언하는 건 씬 이동할 때 SceneTransferManager에서) -> 회전값도 선언

[System.Serializable]
public class Location
{
    public string name;
    public Transform tf_Spawn;
}

void SetPlayerSpawnTransform()
{
        SceneTrasnferManager theSceneMove = FindObjectOfType<SceneTrasnferManager>();
        string locationName = theSceneMove.GetLocationName(); // 장소 이름 가져오기
        Transform spawnTransform = null;
        if (dic_Location.TryGetValue(locationName, out spawnTransform))
        {
            PlayerController.instance.transform.position = spawnTransform.position;
            PlayerController.instance.transform.rotation = spawnTransform.rotation;

            spawn_able = false;
        }
        else Debug.LogWarning("찾을 수 없는 스폰 위치 : " + locationName);
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 14 - 3 씬 이동 연출

1. 페이드 인 / 아웃 연출
씬 이동 시 페이드 인이 끝날때까지 대기 후 씬 이동 (캔버스는 DontDestory가 되어 있기 때문에 화면은 검은색인 상태로 씬 이동) -> 플레이어 위치 선언 후 페이드 아웃

IEnumerator Co_SceneTransfer(string sceneName, string p_locationName)
{
        UIManager.instance.HideUI();
        spManager.FadeOut(false, true);
        yield return new WaitUntil(() => !spManager.isFade);
        
        locationName = p_locationName;
        ScenePositonManger.spawn_able = true;
        SceneManager.LoadScene(sceneName);
}

IEnumerator Co_SceneChangeDone() // SetPlayerSpawnTransform()에서 실행
{
        spManager.FadeIn(false, true);
        yield return new WaitUntil(() => !spManager.isFade);
        if(!EventManager.isAutoEvent) UIManager.instance.ShowUI();
        isTransfer = false;
}

2. 화면 각도 디테일
카메라가 바라보는 방향이 초기화되지 않고 그대로 이동하기 때문에 씬 이동 시 카메라 각도 (카메라는 플레이어의 자식이므로 localTransform 사용하기)

PlayerController.instance.AngleValueReset(); // 플레이어 회전 변수 초기화
PlayerController.instance.ResetCamera(); // 카메라 각도 초기화

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 14 - 4 씬 이동 후 자동 이벤트

1. 자동 이벤트 실행
넘어갈 씬에 오토 이벤트를 설정해놓으면 실행은 되지만 페이드 아웃이 끝나지 않은 상태로 이벤트가 시작하고 카메라 리셋 시 각도를 Quaternion(0, 0, 0) 으로 설정했기 때문에 각도가 전에 바라보던 방향을 보지 않음 -> 씬을 이동하는 동안 true인 static bool isTransfer 변수를 만들고 이벤트는 isTransfer이 false가 될 때까지 대기 후 실행 -> 카메라는 초기 각도를 카메라가 바라보는 방향으로 변경 -> 후에 이동 구현을 위해 bool isMapOnlyView 변수 선언 후 씬 이동 시 다음 맵이 이동 가능한 맵인지 아닌지 여부에 따라 값 대입

2. IsPlayable 프로퍼티
씬 이동 중에는 마우스 이동 등의 플레이를 막아야 하는데 대화나 이벤트 등등 조건이 늘어날 수록 여러 스크립트의 Update()에 조건을 더해야 하는 불편함이 있어 GameManager에 대화와 같은 이벤트가 실행중에 false가 되는 IsPlayable 변수를 읽기 전용 프로퍼티로 선언

public bool IsPlayable
{
        get
        {
            if (DialogueManager.instance.isTalking || EventManager.isAutoEvent || EventManager.isEvent || SceneTrasnferManager.isTransfer)
            {
                return false;
            }
            else return true;
        }
}

if(!GameManager.instance.IsPlayable) return; // 플레이와 관련된 스크립트들의 업데이트 안에 넣고 조건이 추가되면 게임 매니저의 IsPlayable만 변경하면 됨

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 15 움직임 구현

1. 이동 및 회전 구현
I. 이동 : 누구나 아는 마우스 입력 기반의 Translate이동
II. 회전
마우스의 움직임 값을 반환하는 Input.GetAxis("Mouse X") 를 이용하여 회전 ("Mouse Y"도 있음 또한 Mouse의 이동값을 반환하기 때문에 GetAxis와 GetAxisRaw의 차이점이 없음)
위아래 방향으로 제한을 두기 위해 새로운 회전 한계값과 현재 방향값 변수를 선언 후 rotation값이 한계값을 넘지 못하게 함
if(Input.GetAxisRaw("Mouse Y") != 0)
{
            filedCurrentAngle_X -= Input.GetAxisRaw("Mouse Y") * rotationSpeed;
            filedCurrentAngle_X = Mathf.Clamp(filedCurrentAngle_X, -filedLookLimit_X, filedLookLimit_X);
            tf_Camera.localEulerAngles = new Vector3(filedCurrentAngle_X, 0, 0);
}
또한 두개의 축을 동시에 다루면 회전이 이상해지고(멀미를 유발하는 듯이 회전한) Y축 값에만 제한을 적용하기 수직 회전은 카메라를 수평 이동은 플레이어의 회전값을 이용

2. UI 구분
움직일 수 없는 곳에서는 상호작용 이펙트를 끄고 움직일 수 있는 곳에서는 필드 전용 UI를 키고 상호작용할 때 사용하는 Ray 마우스가 아니라 카메라를 기준으로 쏨
void CheckObject()
{
        if (CameraController.isOnlyView)
        {
            mousePosition = new Vector3(Input.mousePosition.x, Input.mousePosition.y, 0);

            if (Physics.Raycast(cam.ScreenPointToRay(mousePosition), out rayHit, 100))
            {
                interactable = Return_Interactable(rayHit.transform);
            }
            else interactable = false;
        }
        else
        {
            if (Physics.Raycast(cam.transform.position, cam.transform.forward, out rayHit, 15))
            {
                interactable = Return_Interactable(rayHit.transform);
            }
            else interactable = false;
        }

        Set_InteractionUI(interactable);
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 16 캐릭터 등장 조건 ** 여기서 사용한 기법은 스토리 기반의 게임을 만들때 많이 사용할듯 **

1. 새로운 클래스 생성 (EventCondition Script)
I. eventFlags선언
먼저 해당 event를 봤는지 안봤는지 확인하는 bool[]변수를 선언함 강의에서는 DataBaseManager에 선언했지만 나는 지난번에 개인적으로 만든 EventManager에 선언함

II. EventCondition 생성
Dialogue에 새로운 커스텀 클래스를 추가하는 방법으로 구현했지만 그러면 InteracitonEvent의 인스펙터 창이 너무 더러워질 것 같아서 새로운 스크립트를 만듬 (InteracitonEvent에서 Dialogue[]를 설정함)  EventCondition을 가지는 오브젝트는 자신이 진행하는 이벤트 넘버와 등장 조건과 관련되있는 이벤트의 넘버를 int[]로 가지고 이벤트를 보는게 등장조건인지 반대가 등장조건인지를 결정하는 bool변수와 (예를 들어 false면 int[]에 있는 이벤트들을 보지 않아야 등장하고 true면 봐야지 등장함) 특정 이벤트를 보면 퇴장하도록 퇴장 이벤트를 int변수를 가짐

public int eventNumber; // 컴포넌트를 가지고 있는 오브젝트가 진행하는 이벤트 넘버 (진행하면 DataBaseManager의 eventFlags의 eventNumber번째가 true가 됨)
public int[] eventConditions; // 등장 조건에 포함되는 이벤트 넘버 (무조건 등장시키려면 0번째 event를 지정하고 conditionFlag을 false로 하면됨)
public bool conditionFlag; // 이벤트를 보는게 등장 조건인지 보지 않은게 등장 조건인지 결정하는 변수 
public int endNumber; // 퇴장 이벤트 넘버

2. 스크립트 적용
I. 이벤트 상태 적용
InteractionController에서 대화가 시작할 때 오브젝트가 EventConditoin컴포넌트를 가지고 있으면 EventConditoin의 eventNumber 째의 eventFlags를 true로 만듬

if (rayHit.transform.GetComponent<EventCondition>() != null)
    EventManager.instance.eventFlags[rayHit.transform.GetComponent<EventCondition>().eventNumber] = true;

II. Start에서 등장 여부 결정
Start에서 등장 여부를 판단함 eventConditions번째의 이벤트들의 값이 전부 conditionFlag와 같아야 하며 endNumber번째의 이벤트가 false여야함private void Start()

private void Start()
{
        gameObject.SetActive(CheckEvent());
}

bool CheckEvent()
{
        bool flag = true;

        // 등장 조건과 일치하지 않을 경우 등장시키지 않음
        for(int i = 0; i < eventConditions.Length; i++)
        {
            if(EventManager.instance.eventFlags[eventConditions[i]] != conditionFlag)
            {
                flag = false;
                break;
            }
        }
        // 등장 조건과 관계없이 퇴장 조건에 만족하면 등장시키지 않음
        if(EventManager.instance.eventFlags[endNumber]) flag = false;

        return flag;
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 17 말 걸면 달라지는 대사

1. AfterLine 변수 추가
Dialogue에 대사 후에 나올 대사를 가져오는데 사용할 afterLine 변수 선언
public Vector2 afterLine; // 대화 한번 한 후에 다음 대화

2. 다음 대사 출력
대사를 가져올 때 해당 이벤트를 이미 진행했으며 대화 후 다음 대사가 있다면 원래 대사가 아니라 AfterLine의 대사를 출력함 그러기 위해  출력할 대사의 행의 줄을 받아 대사를 반환하는 SetDialogueEvent 함수를 만들고 사용

private void Start()
{
        dialogueEvent.dialogues = SetDialogueEvent(dialogueEvent.dialogues, (int)dialogueEvent.line.x, (int)dialogueEvent.line.y); // 처음에 진행할 이벤트의 기본 대사 선언
        gameObject.SetActive(CheckEventAppearCondition(dialogueEvents[0]));
}

Dialogue[] SetDialogueEvent(Dialogue[] p_Dialogue, int p_LineX, int p_LineY)
{
        Dialogue[] t_Dialogue = DataBaseManager.instance.GetDialogues(p_LineX, p_LineY);
        for (int i = 0; i < t_Dialogue.Length; i++) // 각종 변수 대입
        {
            // 이름 앞에 ⒳가 붙어 있으면 타겟팅 안하는거임 
            if (t_Dialogue[i].name[0] != '⒳') t_Dialogue[i].tf_Target = CharacterManager.instance.dic_Character[t_Dialogue[i].name];

            // target은 현재 대화 상대를 의미 주인공이 말하거나 독백할때도 target에는 대화상대가 들어감
            if (t_Dialogue[i].tf_Target == null) t_Dialogue[i].tf_Target = currentTarget;
            else currentTarget = t_Dialogue[i].tf_Target;

            if (p_Dialogue.Length > i) // 인스펙처 장에서 선언한 dialogueEvents 덮어쓰기용
            {
                t_Dialogue[i].cameraType = p_Dialogue[i].cameraType;
            }
        }
        return t_Dialogue;
}

public Dialogue[] GetDialogues() // 대화 여부에 따라 다른 대화 정보를 보냄
{
        if (!EventManager.instance.eventFlags[CurrentEventNumber] || dialogueEvent.afterLine.y == 0) // 대화 후 대사가 없으면 같은 대사 출력
        {
            return dialogueEvent.dialogues;
        }
        else return SetDialogueEvent(dialogueEvent.dialogues, (int)dialogueEvent.afterLine.x, (int)dialogueEvent.afterLine.y);
}

3. 일회용 이벤트
같은 대화를 여러번 하면 여러 이벤트(캐릭터 등장 등)가 중복 실행될 수 있기 때문에 이벤트를 한 번 봤으면 실행 안하는 조건 추가

public void GameEventByTalkEnd(EventByTalk eventByTalk)
{
        if (eventByTalk == null || eventByTalk.eventType == EventType.None || eventByTalk.showEvent) return;
        eventByTalk.showEvent = true;
        AppearOrDisappearCharacter(eventByTalk.eventType, eventByTalk.eventCharacters);
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 18 다중 이벤트 설정

1. 기존 DialogueEvnet DialogueEvent[]로 선언
한 오브젝트가 여러개의 이벤트를 진행할 수 있기 때문에 기존의 대화 정보를 배열로 선언하고 현재 진행하는 이벤트 index를 나타내는 currentEvent 선언

2. 조건 검사
기존의 CheckEvent()를 오브젝트가 등장할지 말지가 아니라 Event를 진행할지 말지로 기능 확장 즉, 보유 중인 이벤트 중에 등장 조건이 맞는 이벤트가 있으면 그 이벤트를 실행하고 없으면 마지막에 했던 대화 실행 후 씬 넘어가면 퇴장

int number;

int currentEvent
{
        get
        {
            for(int i = 0; i < dialogueEvents.Length; i++)
            {
                if (CheckEventAppearCondition(dialogueEvents[i]))
                {
                    number = i;
                    return i;
                }
            }
            return number;
        }
}

// CheckEvent에서 이름 바꿈
bool CheckEventAppearCondition(DialogueEvent p_Event)
    {
        bool flag = true;

        for (int i = 0; i < p_Event.eventConditions.Length; i++)
        {
            if (EventManager.instance.eventFlags[p_Event.eventConditions[i]] != p_Event.conditionFlag)
            {
                return false;
            }
        }

        // 등장 조건과 상관 없이 퇴장 조건을 만족하면 등장시키지 않음
        for (int i = 0; i < p_Event.endNumbers.Length; i++)
        {
            if (!EventManager.instance.eventFlags[p_Event.endNumbers[i]]) break;
            if (i == p_Event.endNumbers.Length - 1) flag = false;
        }

        return flag;
}

3. 이벤트 실행 
currentEvent는 현재 진행중인 대사의 정보를 가지고 있는 DialogueEvent[]의 index를 나타내는 함수이므로 현재 진행중인 이벤트 넘버를 가지는 currentEventNumber 변수를 선언 후 InteractionController에서 사용

public int CurrentEventNumber
{
        get
        {
            return dialogueEvents[number].eventNumber;
        }
}

InteractionController 스크립트
if (rayHit.transform.GetComponent<InteractionEvent>() != null)
            EventManager.instance.eventFlags[rayHit.transform.GetComponent<InteractionEvent>().CurrentEventNumber] = true;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

** 내 파트 엑셀 파싱 방법 변경 **
강의에서 진행한 파싱은 캐릭터를 기준으로 클래스를 만들고 이 클래스를 줄 개념으로 1 ~ 2번째 줄을 가져오는 거였는데 이것의 문제점은 대사마다 나뉘어져있지 않고 줄끼리 다닥다닥 붙어 있어서 분류가 어렵고 대사가 10000줄가 넘어가면 그거를 어떤 줄에 어떤 대사가 있는지 기억하고 찾아가는게 사실상 불가능하기 때문에 나는 기존 캐릭터 기준으로 묶은 클래스를 또다시 묶어 대화를 이벤트 이름을 기준으로 묶기로 하였다.

1. 데이터 파싱 변경
기존에 do while로 묶어서 캐릭터 기준으로 Dialogue를 만들던 부분을 While로 묶는다. 이벤트가 끝나는 부분에 조건은 엑셀 파일에 eventname이 end이면 탈출 end는 이벤트 대사가 끝나 다음 줄에 들어간다.
-> 기존에는 Dialogue[]로 모든 대사를 분류했지만 이벤에 Dialogue[]를 eventname을 기준으로 한번 더 묶기 때문에 Parse의 반환 타입을 Dialogue[]에서 List<Dialogue[]>로 바꿈 
-> Parse함수는 for -> while -> do while로 이어지는 3중 반복문으로 상당히 로직이 빡세고 작업중에 무한 루프에 빠져서 unity를 10번은 넘게 끈거 같다 
-> 함수에서 반복문을 제외한 부분에서는 반환할 List<Dialogue[]> 인스턴스를 선언하고 가져온 엑셀파일을 줄바꿈 기준으로 나눈 datas를 선언한 후 for문을 실행 
-> for문은 datas의 길이만큼 반복하도록 설정됐지만 i++가 없고 반복문 내부에서 i연산이 이뤄지므로 실제로 for문이 datas의 길이만큼은 돌지 않으며 사실상 while과 비슷하게 사용된다. 코드로 들어가면 시작 부분에서는 datas의 i번째의 정보를 ,로 구분한 row를 선언하고 나중에 Dialogue[]로 변환할 List<Dialogue> 인스턴스를 선언한다. 후에 row의 0번째가 eventname이므로 row[0]에 공백이나 end가 들어가 있으면 i++를 한 후 continue를 실행해 유효한 이벤트 이름이 나올때까지 row에 새로운 정보를 갱신하고 유호한 데이터가 나오면 while을 실행한다 
-> while은 eventname이 end면 탈출한다. 코드로 들어가면 우선 for문에서 선언한 List<Dialogue> 에 Add할 Dialogue를 인스턴스하고 Dialogue의 name을 선언 후 변수에 대입할 List들을 인스턴스하고 
do while을 실행한다. 
-> do while의 조건은 row[1] 즉 캐릭터 이름이 공백이 아니면 탈출한다. 공백이 아니라면 다음 캐릭터의 대사를 넣어야 한다는 뜻이므로 설정한 조건이지만 일반 while을 사용하면 캐릭터가 대사를 한번만 하는 경우 반복문이 작동하지 않기 때문에 무조건 한 번은 실행하는 do while을 사용했다. 코드로 들어가면 우선 row[2] 즉 현재 엑셀 행의 대사가 공백이면 탈출하는 조건문이 있다. 이는 do while은 공백을 기준으로 탈출하는데 대화가 끝나면 다음 줄은 eventname에 있는 end 빼고 공백이라 이를 방지한 조건문이다. 조건을 만족하면 while에서 선언한 List 들의 데이터를 Add하고 i++를 한 후 row를 갱신하고 조건을 검사하고 조건에 맞으면 반복문을 탈출한다 
-> do while을 탈출한 후 whlile의 마지막 부분에서는 do while에서 선언한 list들을 배열로 형변환해 dialogue 변수에 대입하고 for에서 선언한 List<Dialogue>에 Add한다. 
-> while을 탈출한 for문의 마지막 부분에서는 while에서 세팅한 Dialogue[]를 함수 초반에 선언한 List<Dialogue[]>에 형변환 후 Add한다 -> 반복문이 끝나면 List<Dialogue[]>를 반환한다.

public List<Dialogue[]> Parse(string _CsvFileName)
    {
        List<Dialogue[]> dialoguesList = new List<Dialogue[]>();

        // Resources폴더에 있는 csv 파일 가져옴
        TextAsset csvData = Resources.Load<TextAsset>(_CsvFileName); // TextAsset : csv파일을 담을 수 있는 데이터 구조

        string[] datas = csvData.text.Split(new char[] { '\n' }); // 줄바꿈(한 줄)을 기준으로 csv 파일을 쪼개서 string배열에 줄 순서대로 담음

        // for문에 i++를 넣지 않고 while문처럼 사용
        for (int i = 1; i < datas.Length;) // 엑셀 파일 1번째 줄은 편의를 위한 분류이므로 i = 1부터 시작
        {
            // A, B, C열을 쪼개서 배열에 담음 (CSV파일은 ,로 데이터를 구분하기 때문에 ,를 기준으로 짜름)
            string[] row = datas[i].Split(new char[] { ',' });
            List<Dialogue> dialogueList = new List<Dialogue>();

            if (row[0].Trim() == "" || row[0].Trim() == "end") // 유효한 이벤트 이름이 나올때까지 반복
            {
                i++;
                continue;
            }
            while (row[0].Trim() != "end" && i < datas.Length)
            {
                Dialogue dialogue = new Dialogue();
                dialogue.name = row[1];

                // 캐릭터가 한번에 치는 대사를 담을 리스트 캐릭터가 치는 대사의 길이를 모르므로 리스트로 선언
                List<string> contextList = new List<string>();
                List<string> spriteList = new List<string>();
                List<string> voiceList = new List<string>();
                List<string> sceneList = new List<string>();

                do // do while : 무조건 한번 실행하고 while의 조건 확인 후 돌지 말지 결정
                {
                    if (row[2].Trim() == "") break; // 대사 넣다가 다음줄이 공백이면 대화가 끝났다는 뜻 즉, 끝나면 탈출하는 조건문

                    contextList.Add(row[2]);
                    spriteList.Add(row[3]);
                    voiceList.Add(row[4]);
                    sceneList.Add(row[5]);

                    if (++i < datas.Length)
                    {
                        row = datas[i].Split(new char[] { ',' });
                    }
                    else break;
                } while (row[1].ToString() == "");
                // row[1]이 공백이라는 뜻은 한 캐릭터가 여러 대사를 치고 있다는 뜻이므로 contextList에 대사를 추가하기 공백이 아닐 때까지 반복문을 돔

                // 위에서 생성한 대사 리스트를 dialogue.contexts에 대입
                dialogue.contexts = contextList.ToArray();
                dialogue.spriteNames = spriteList.ToArray();
                dialogue.voiceNames = voiceList.ToArray();
                dialogue.cutSceneName = sceneList.ToArray();

                // for문 한번 돌때마다 dialogueList에 dialogue가 하나씩 추가되며 엑셀파일의 데이터를 dialogueList에 다 담게 됨
                dialogueList.Add(dialogue);
            }

            dialoguesList.Add(dialogueList.ToArray());
        }
        
        return dialoguesList;
}


2. 딕셔너리 선언 변경 및 사용
<int, Dialogeu>였던 기존 딕셔너리의 타입을 <string, Dialogeu[]>로 바꾼 후 eventName을 기준으로 대화 데이터를 반환한다.

public Dialogue[] GetDialogues(string name)
{
        Dialogue[] dialogues = null;
        if (Dic_dialogue.TryGetValue(name, out dialogues)) return dialogues;
        else
        {
            Debug.Log("찾을 수 없는 이벤트 이름 : " + name);
            return null;
        }
}

더 이상 InteractionEvent에서 Vector2를 통한 시작과 끝 행이 아닌 eventName으로 가져옴
SetDialogueEvent(dialogueEvent.dialogues, dialogueEvent.eventName);

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 完 : 잠긴 문 개방

1. 문에 InteractionEvent추가
문에 InteractionEvent를 추가하여 문이 열리렬면 봐야하는 이벤트 설정

2. 사용
InteractionController에서 door일 때 InteractionEvent를 가지고 있으며 이벤트 번호가 일치하면 대화 이벤트 번호가 일치하지 않으면 맵 이동 (나중에 이벤트랑 관련없는 대사만 출력하는 엑셀 파일을 따로 만들고 이벤트 조건만 검사해야 할 듯)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

내 파트 : 빨리감기
Talk() 조건에 ctrl 클릭 조건을 || 로 추가해 ctrl누를 때도 대화가 진행되게 하고 대화 시 ctrl을 누르고 있으면 대화 코루틴에서 한 글자를 더하는 딜레이 타임을 0으로 함

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

내 파트 : 상호 작용 리펙토링
원래는 문하고 캐릭터 상호작용 구분을 InteractionTyp의 bool값을 가지고 eif문으로 했는데 딱 봐도 구려서 상속과 가상 함수를 사용해서 코드를 읽기 편하게 하고 확장이 쉽도록 함

가상 함수 StartInteraction(){} 을 선언하고 CharacterDialogue 스크립트를 만들고 상속받음 문은 원래 있던 스크립트에 상속받고 가상함수 구현 기존에 InteractionController에서 구현한 기능은 다 가상함수로
옮김

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

csv파일 한글 깨질 때는 메모장으로 드래그해서 인코딩 utf-8로 바꿔서 저장해야됨





















