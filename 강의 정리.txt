Part 1 기본 무대 및 UI 세팅
I. Edit -> Grid and Snap Setting을 이용하여 편하게 맵 만들기 (마우스를 통해 오브젝트를 한번 움직일 때마다 얼마나 움직일지를 설정할 수 있음)
II. UI 에서 Anchor Position을 설정할 때는 부모는 상단, 하단 처럼 전체적인 틀을 잡고 자식을 구석과 같이 디테일하게 설정하면 좋음 가운데에 있는 애들은 굳이 설정 안해도 해상도 맞춰짐 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 1 크로스헤어 구현
1. [SerializeField] 는 private의 보호 수준은 유지하면서 인스펙터 창에 변수의 값을 보이게 함(할당도 가능)

2. 크로스헤어가 마우스 따라가게하기

I. 크로스 헤어의 포지션 값 
크로스헤어 UI는 Canvas의 자식 오브젝트이므로 원하는 좌표 값을 얻거나 할당하기 위해서는 부모 객처를 기준으로 상대적으로 얼마나 떨어져 있는지를 나타내는 localposition을 사용해야함

이때 Input.mouseposition 값을 크로스헤어의 포지션값에 그대로 적용했을 때 Input.mouseposition값은 화면 왼쪽 아래를 기준으로 0, 0을 가지기 때문에 마우스를 왼쪽 아래 구석에 가져가면 크로스헤어가 가운대로 오는 기적을 감상할 수 있기 때문에 x, y축에 스크린의 넓이와 높이의 반만큼 빼줘야함 그러면 왼쪽 아래 구석에 마우스를 놀 때 크로스 헤어의 포지션 값에 0, 0에서 화면 크기의 넓이와 높이의 반만큼 뺸 값이 대입되기 때문에 마우스와 똑같이 위치함

II. Screen : 디스플레이 정보에 접근하는데 사용하며 지원되는 해상도 목록을 가져오거나 변환하는데 사용됨
Screen.width : 해상도를 기준으로 화면의 넓이를 가져오며 단위는 픽셀을 사용(height는 높이) 

III. 주의사항
스크린의 크기는 해상도를 기준으로 가져오고 크로스헤어는 UI이므로 Canvas Sclaer의 Reference Resolution 값을 기준으로 위치하기 때문에 Reference Resolution의 값과 해상도 값을 일치시켜야함
만약 해상도를 Reference Resolution 값보다 크게 하면 스크린 값이 Canvas보다 크게 설정되어 크로스헤어의 포지션이 마우스 위치와 달라짐

Screen 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Screen.html
Input.mousePosition 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Input-mousePosition.html

3. 크로스헤어가 화면 밖으로 나가지 않게 하기
필요성 : Input.mouseposition는 마우스 포인터가 화면 밖에 있어도 위치를 보고하기 때문에 크로스헤어가 화면밖으로 나가 보이지 않을 수 있어 크로스헤어의 위치에 제한을 두어 화면 밖으로 나가지 않게 함

I. Mathf.Clamp()함수 
Mathf.Clamp(float value, float min, float max) : 기본적으로 value의 값을 반환하지만 value가 min보다 작으면 min을 max보다 크면 max값을 반환함 즉 기본적으로 vlaue를 반환하되 원하는 범위만큼 제한을 둔 값을 반환할 수 있음 value의 값에는 영향을 주지 않고 오직 반환값만 제한됨 

II. 마우스 포지션 값과 스크린 크기 값에 기반해 먼저 크로스헤어의 x, y 변숫값을 구한 후 그 변수에 이 함수를 통해 스크린의 크기만큼 제한한 값을 대입해 크로스헤어가 화면 밖으로 나가는 것을 방지함 

private float cursorMargin = 30; // 마진을 다 크로스헤어의 모든 부분이 화면에 보이게 하기 위한 여백값
// 크로스 헤어의 좌표값 구함
float corsshair_X = Input.mousePosition.x - Screen.width / 2;
float corsshair_Y = Input.mousePosition.y - Screen.height / 2;

// corsshair가 화면 밖으로 나가는거 방지하기 위해 스크린 크기만큼 제한한 값을 다시 할당
corsshair_X = Mathf.Clamp(corsshair_X, -Screen.width / 2 + cursorMargin, Screen.width / 2 - cursorMargin);
corsshair_Y = Mathf.Clamp(corsshair_Y, -Screen.height / 2 + cursorMargin, Screen.height / 2 - cursorMargin);
tf_Corsshair.localPosition = new Vector2(corsshair_X, corsshair_Y);

4. 강의 내용 외의 시도

I. RectTranform을 사용할 경우 크로스헤어가 마우스를 그래도 따라가지만 여전히 좌측 하단이 0, 0이기 때문에 Screen의 크기를 이용해 크로스헤어의 범위에 제한을 두는 데에 문제가 생김
RectTransform을 사용하면 마우스를 그대로 따라가는 이유는 RectTransform도 좌측 하단이 0, 0 이디 때문임
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 2 뷰 회전 (크로스 헤어)

1. 크로스헤어가 끝부분에 있으면 그쪽 방향으로 회전하기

I. Part 2 - 1에서 구현한 크로스 헤어의 위치값이 스크린의 절반보다 크거나 작으면 작동하는  조건문 제작
if( corsshair_X > half_ScreenWidth - 80 || corsshair_X > -half_ScreenWidth + 80 )

II. 삼항 연산자를 통해 x좌표의 부호에 따라 회전값 변수에 회전 속도 변수를 더하거나 뺌
currentCameraAngle_Y += ( corsshair_X > 0 ) ? rotateSpeed : -rotateSpeed; 

III. 연산이 이뤄진 회전값 변수에 Mathf.Clamp() 함수를 이용하여 회전값에 제한을 둔 후 카메라 회전값에 대입함
currentCameraAngle_Y = Mathf.Clamp(currentCameraAngle_Y, -look_X_Limit, look_X_Limit);
같은 방법으로 currentCameraAngle_X를 구한 후 대입( 이때 x축 회전값의 방향은 더하면 내려가고 빼면 올라가기 때문에 삼항연산자 부호를 반대로 해야함)
th_Camera.rotation = Quaternion.Euler(new Vector3(currentCameraAngle_X, currentCameraAngle_Y, 0));

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 3 뷰 이동 및 회전 (방향키)

1. 키보드를 이용한 회전 구현

I. 수평 수직 키 입력을 받는 Input.GetAxisRaw값을 이용해 Part 2 - 2의 방법을 그대로 적용하여 회전 구현 (GetAxis값은 입력에 따라 음수 양수 값이 나오기 때문에 삼항연사자는 필요 없음) 
이때 Input.GetAxisRaw는 -1, 0, 1의 값 3가지만 반환하며 Input.GetAxis는 -1, 1까지의 값을 반환한다 즉 부드러운 이동은 Input.GetAxis를 키보드와 같이 입력 시 바로 반응해야 하는 경우에는 Input.GetAxisRaw를 사용한다.
float getKey_X = Input.GetAxisRaw("Horizontal");
if (getKey_X != 0) currentCameraAngle_Y += getKey_X * playerRotateSpeed;


2. 플레이어 이동 구현

I. 회전할 때 회전 방향과 같은 방향으로 이동 나는 강의에서랑 조금 다르게 float 파라미터를 가진 함수를 만들어 인자값의 부호에 따라 속도 변수만큼 움직이는 함수를 만든 후 회전 조건문 안에 넣음
void MoveX(float moveDirection)
{
    float move_X = (moveDirection > 0) ? playerMoveSpeed : -playerMoveSpeed;
    tf_Camera.localPosition += Vector3.right * move_X;
}

II. 실제 함수 사용
if(corsshair_X > half_ScreenWidth - 80 || corsshair_X < -half_ScreenWidth + 80)
{
    currentCameraAngle_Y += (corsshair_X > 0) ? playerRotateSpeed : -playerRotateSpeed;
    MoveX(corsshair_X); // 회전의 기준이 되는 corsshair_X를 argument값으로 넣음 (키보드는 GetAxisRaw값)
}
Y축 이동은 방향만 바꾼 후 똑같이 함수 만들고 똑같이 적용함


3. 플레이어 이동 위치 제한 구현
카메라 위치가 지정한 변숫값보다 크거나 작으면 그 포지션 값을 변수값으로 고정
if(tf_Camera.localPosition.x > move_X_Limit || tf_Camera.localPosition.x < -move_X_Limit)
{
	tf_Camera.localPosition = new Vector3( (tf_Camera.localPosition.x > 0) ? move_X_Limit : -move_X_Limit ,  tf_Camera.localPosition.y, tf_Camera.localPosition.z);
}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 4 디테일 (Spin 및 추가 UI)
1. 해당 방향으로 회전을 못할 때 회전을 못한다는 것을 알려주는 UI 제작

I. UI 4개 만들고 현재 회전값이 지정한 최대 방향값보다 높으면 해당 방향의 금지 모양 UI의 SetActive(true)하고 아니면 false하기

2. 크로스헤어의 노란색 부분이 아톰 홈페이지마냥 계속 빙글빙글 돌아가게 만들기 (Spin Script)

I. transform.Rotate(Vector3 eulers) : argument값의 Vector3만큼 회전시키는 함수 Translate()랑 비슷함
II. Time.deltaTime : 이전 프레임과 현재프레임의 시간차이를 반환함 1초에 60프레임이라면 1 / 60 반환 Update문에서 속도 변수에 곱하면 1초에 원하는 값만큼 움직여서 따로 복잡한 연산이 필요없음
transform.Rotate(spinDir * spinSpeed * Time.deltaTime);

3. 상수를 변수로 바꾸기

I. const와 readonly
공통점 : 둘 다 변수를 상수로 선언해 재할당이 불가능하다

차이점 : const는 컴파일 타입의 상수이고 readonly는 런타임 타입의 상수이다. 즉 const는 컴파일 시 변숫값을 가져오고 readonly는 exe, dll 등의 파일 실행 시 값을 가져온다 이 때문에 const를 사용하면 조금이라도 프로그램에 더 빠르게 접근 가능하지만 상숫값을 변경할 때 그 값과 관련된 프로젝트를 모두 다시 컴파일해야하는 단점이 있다 때문에 상숫값 변경 시 재 컴파일을 하지 않고 사용하는 생성자 단계에서 변수에 값을 할당하는 readonly가 더 각광받고 있는 추세이다.

관련 내용 블로그 : https://holjjack.tistory.com/95

II. 카메라 상수 변수로 바꾸기
카메라의 Y포지션이 0이 아닌 1이기 때문에 카메라 포지션 제한값을 둘 때 1에 지정한 위치값을 더하는 형식으로 카메라 위치를 제한했는데 이를 게임 시작 시 현재 카메라 Y값을 변수에 대입해 1대신에 사용
이럴 경우 후에 카메라의 위치가 바뀌어도 카메라의 위치값을 변수에 대입하기 때문에 코드를 건드리지 않아도 됨

originPos_CameraY = tf_Camera.localPosition.y;

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 1 상호작용
1. 상호작용 가능한 객체 위에 마우스 울리면 UI 변하기
I. 상호작용 전용 여러 이미지를 겹치게 해서 UI Interactive_Corsshair 제작하기

2. 카메라에서 Ray발사하기 (IntreactionCortroller Script)

I. 게임 카메라 상에서의 마우스 포지션을 게임에서의 월드 포지션으로 바꾼 후 그 값을 이용하여 Ray를 쏴야 함
이를 구현하기 위해 Camera 클래스에 있는 함수인 SceenPointToRay()에 마우스 포지션 값(카메라가 보고있는 스크린의 점)을 넣어 ray를 반환함
이때 ray는 발사할 Ray의 시작점과 방향을 둘 다 Vector 값으로 가짐  ex) Origin : (1, 0, 3), Dir : (0.7, 0, 0.3)
if (Physics.Raycast(cam.ScreenPointToRay(mousePosition), out rayHit, 100))

ScreenPointToRay 관련 Unity Manual : https://docs.unity3d.com/kr/current/Manual/CameraRays.html
Physics.Raycast 관련 Unity Manual : https://docs.unity3d.com/kr/530/ScriptReference/Physics.Raycast.html

II. 
ray가 맞은 오브젝트의 태그가 Interaction이면 Interactive_Corsshair를 아니면 Normal_Corsshair를 보여줌

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 2 상호작용 이펙트
1. 상호작용 파티클 이펙트 만들기

I. 목표 : 물음표 모양을 한 스프라이트 이미지를 던지는 형식의 이펙트를 연출할 것이므로 딱 한번만 파티클이 나와야 하고 나오는 파티클을 미리 준비한 스프라이트 이미지로 바꾸어야함

II. Emission의 Rate over Time (시간 경과에 따른 입자 방출 수)를 0으로 하고 Bursts (시작 시 방출하는 파티클)의 Count를 1로 함 그리고 파티클의 모양을 스프라이트로 하기 위해 Texture Sheet Animation의 Mode를 Grid에서 Sprites로 바꾼 후 미리 준비해둔 스프라이트를 넣음 그리고 Render에서 Material을 Default-ParticleSystem으로 설정해야 보라색 버그 입자가 아닌 스프라이트가 정상적으로 나옴

III. 그대로 날아가면 재미가 없기 때문에 회전하면서 날아가도록 Rotation over Lifetime에서 Separate Axes를 체크 후 회전 방향을 설정함

IV. 이펙트가 물체에 닿았을 때 터지는 이펙트 만들기
사이즈를 줄이고 StartSpeed를 빠르게 한 후 Bursts의 Count를 20으로 설정하고 사방으로 퍼지도록 Shape를 shpere로 Radius(입자가 뿜어져 나올 영역의 크기로 0에 가까울 수록 한 점에서 뿜어져 나옴)를 0에 가깝게 설정 후 Size over Lifetime을 이용해 입자가 점점 작아지게 설정하고 입자가 원이 아니라 선처럼 뻗어나가도록하게 하기 위해 Render에서 Render Mode를 Billboard에서 Stretched Billboard로 설정 후 Speed나 Length에 따라 찢어지는 정도를 설정 

2. 파티클 투척하기

I. 상호작용이 가능한 상태에서 좌클릭을 하면 파티클이 실행됨 if(Input.GetMouseButtonDown(0) && interactable)

II. 부드러운 움직임을 위해 Lerp(Vector3 start, Vector3 end, float t) 함수를 이용해 이동 (end - start)/ t 만큼 움직임 0.5f면 1 / 2만큼 움직임
상호작용하려는 물체와 충분히 가까워지면 HitEffect를 Play함

III. 오브젝트의 Pivot를 바꿔서 이펙트를 타겟의 transform.position을 기준으로 발사할 때 이미지의 상반신을 향하게끔 바꿈
pivot 변경하는 방법을 다룬 블로그 : https://mariageunit.blogspot.com/2019/07/unity-1.html

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 3 상호작용 이벤트

1. 상호작용 대화창 만들기
I. 대화내용이 나오는 대화창 UI와 상호작용하는 객체의 이름이 나오는 UI 2개를 만듬

II. 새로운 스크립트인 DialogueManager(싱글톤)를 만들어 상호작용 이펙트가 객체와 충돌한 시점에서 대화 관련 UI가 나오도록 함

III. UIManager(싱글톤) 스크립트를 새로 만들어 대화중에는 화살표와 크로스헤어 UI 숨기기 

IV. DialogueManager에 대화중인지를 나타내는 bool 변수 isTalking을 선언하고 대화 중에는 화면 이동과 상호작용(클릭)을 하지 못하도록 함

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 3 - 4 디테일 (Tooltip + 추가 연출)
1. 상호작용 가능한 객체에 크로스헤어를 갖다대면 툴팁과 이펙트 뜨게 하기
I. 툴팁 UI, 인터랙션 UI 각각에 맞는 이미지 넣어서 만들기

II. 새로운 스크립트인 InteractoinType 만든 후 어떤 유형의 상호작용 객체인지 판별하기 위한 변수 및 이름 변수 선언 (골드메탈 쯔꾸르 대화기능 구현할 isNpc같이 script로 타입을 구분)
만든 후 봉란 객체에게 스크립트 부여 후 변수 선언 후 상호작용 가능한 상태에서 툴팁 UI와 객체 이름 뜨게 하기

interactable은 상호작용가능 여부
obj_TargetNameBar.SetActive(interactable);
txt_TargetName.text = (interactable) ? rayHit.transform.GetComponent<InteractionType>().GetName() : "";

III. 상호작용 이펙트
크로스헤어 갖다대면 이펙트 나타나게 하기, 코루틴을 이용해 늘 하던 while을 이용해 투명도 값을 조절하는 연출 이용 이때 기존의 Set_InteractionUI(bool interactable) 함수는 업데이트에서 돌아가기 때문에 코루틴 중복실행으로 그대로 확장이 불가능 그렇기에 isContact 변수를 만들어 중복실행을 막음
if (isContact == interactable) return;  
isContact = interactable;

그리고 새로 안 사실인데 코루틴을 문자열로 이용할때도 인수 하나까지는 커버를 칠 수 있었음 StartCoroutine("Co_AppearInteractionImg", true); 이런 식으로 사용하면 인수 하나있는 코루틴까지는 편하게 
정지가 가능 여기서도 중복 실행 방지를 위해 코루틴 사용 전에 StopCoroutine()를 사용함

IV.마름모 이미지가 점점 커지면서 투명해지는 이펙트 만들기
Vector3.Set(float x, float y, float z) : Vector3 변수를 설정(Set)하는 함수 = 으로 선언하는거랑 비슷함
상호작용 가능한 객체에 크로스헤어를 올리고 있으며 대화중이 아닌 상태에서 계속 돌아가는 무한반복 코루틴 만들기
IEnumerator Co_InteractionEffect()
    {
        float delayTime = 0.02f;
        WaitForSeconds ws = new WaitForSeconds(delayTime);

        // 상호작용 가능한 객체에 크로스헤어를 올리고 있으며 대화중이 아닌 상태에서 계속 돌아가는 무한반복 코루틴
        while (interactable && !DialogueManager.instance.isTalking)
        {
            Color color = img_InteractionEffect.color;
            color.a = 0.5f;

            img_InteractionEffect.transform.localScale = new Vector3(1.3f, 1.3f, 1.3f);
            Vector3 img_Scale = img_InteractionEffect.transform.localScale;

            while(color.a > 0 && !DialogueManager.instance.isTalking && interactable)
            {
                color.a -= 0.01f;
                img_InteractionEffect.color = color;
                img_Scale.Set(img_Scale.x + delayTime, img_Scale.y + delayTime, img_Scale.z + delayTime);
                img_InteractionEffect.transform.localScale = img_Scale;
                yield return ws;
            }
            yield return null;
        }
    }

V. 대화 중에는 상호작용 UI 안보이게 예외처리하기

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 1 데이터 파싱 및 엑셀 관리 ** 존나 중요하며 존나 길고 존나 어렵고 존나 재밌는 파트 ** 이번 파트는 전체적인 흐름만 적고 디테일한건 주석처리함
방대한 양의 대사들을 유니티에서 관리하면 비효율적이기 때문에 대사들을 엑셀 파일에서 관리하고 ,로 구분하는 데이터 자료형인 CSV(Comma Split Value)로 파싱 후 유니티로 불러들여 대화 기능을 구현

대사 클래스 (Dialogue Script) -> 대사 이벤트 클래스 (Dialogue Script) -> 엑셀파일 파싱 클래스 (DialogueParser Script) -> 파싱된 데이터를 저장하는 데이터베이스 매니저 클래스 (DataBaseManager Script) 
-> 상호 작용 이벤트 클래스 (InteractionEvent Script) -> 상호작용 컨트롤러 (InteractionController Script)에서 사용

1. 엑셀 데이터를 담을 틀을 가진 커스텀 클래스 2개 제작 (Dialogue Script)
이름과 대사(배열) 변수를 가진 Dialogue 클래스 Dialogue를 배열로 가지고 있고 엑셀 파일의 몇 번째 줄부터 몇 번째 줄까지를 가져올지 정하는 Vector2 변수를 가지고 있는 DialogueEvent 클래스 선언 
이 스크립트는 MonoBehaviour을 상속받지 않으므로 오브젝트의 컴포넌트로 직접 넣을 수 없고 InteractionEvent에서 수정할 것이기 때문에 둘 다 [System.Serializable]를 선언해 인스펙터 창에서 수정 가능하게
만듬

2. 엑셀파일 파싱 클래스 제작 (DialogueParser Script)
줄과 열(,)을 기준으로 Split함수를 이용해 데이터를 나눠서 string[] 변수에 담고 반복문을 사용해 Dialogue Script의 변수를 형식에 맞게 선언 후 반환하는 함수 제작
엑셀 파일을 csv파일로 변환했을 때 visual studio를 통해서 csv파일을 열어서 빈 줄이 있는지 확인하기 비어있는 줄이 있으면 빈 줄을 가져오려고 해서 에러 뜸

3. 파싱된 데이터를 저장하는 데이터베이스 매니저 클래스 제작 (DataBaseManager Script)
줄에 매칭되는 Dialogue Script를 가지는 딕셔너리 변수 선언 후 2.에서 만든 함수를 통해 얻은 배열을 이용해 반복문을 이용해 변수에 값 대입 후 시작 행과 끝 행을 인자로 받아 받은 줄의 데이터들의 배열을 반환하는 함수 제작

4. 상호 작용 이벤트 클래스 제작 (InteractionEvent Script)
객체에 들어가는 실질적으로 데이터를 가지는 스크립트
[SerializeField] DialogueEvent dialogueEvent; 변수를 가지며 3.에서 만든 함수에 1.에서 선언한 Vector2 변수의 x, y 값을 형변환 후 대입해 원하는 데이터를 변수에 선언하는 함수 제작

5. 상호작용 컨트롤러 (InteractionController Script)에서 사용
이전 파트에서 제작한 이펙트가 터지는 순간에 다이로그 바가 뜨는 함수에 4.에서 만든 함수 사용부분 추가

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 4 - 2 대화 시스템 구현
1. 대화 기능 구현

I. 대사 치환 
csv파일은 ,로 데이터를 구분하기 때문에 대사에 ,를 쓰지 못하고 대신 |을 사용했는데 Replace()함수를 사용해서 |를 ,로 치환하기
string.Replace(string oldValue, string newValue) : string 변수에 old변수가 포함되어 있으면 newValue로 치환해주는 함수

II. 대사 출력 
캐릭터 대화의 순서를 나타내는 talkIndex변수와 대사의 순서를 나타내는 contextCount변수 다음 대화로 넘어갈 수 있는지를 나타내는 isNext변수 선언 후 대화 기능 구현에 사용
Update()문에서 isNext && isTalking && 마우스 또는 키보드 입력 시 실행되는 Talk()함수 선언
대화 한번마다 contextCount++시키고  한 캐릭터가 가지는 대사의 길이와 같아지면 contextCount = 0으로 하고 talkIndex++ 후 다시 대사 시작 talkIndex가 Dialogue[] 의 길이를 넘기면 대화 종료
void Talk()
{
        isNext = false;
        txt_Dialogue.text = "";
        if (++contextCount >= dialogues[talkIndex].contexts.Length)
        {
            contextCount = 0;
            talkIndex++;
        }

        if (talkIndex < dialogues.Length) StartCoroutine(Co_TypeWriter());
        else EndTalk();
}

III. 대사 타이핑 효과 구현
코루틴을 이용하여 한글자씩 대사를 추가
IEnumerator Co_TypeWriter()
{
        Set_DialogueUI(true);
        txt_Name.text = dialogues[talkIndex].name;
        txt_Dialogue.text = "";

        string replaceText = dialogues[talkIndex].contexts[contextCount];
        replaceText = ReplaceText_ToComma(replaceText);
        for (int i = 0; i < replaceText.Length; i++)
        {
            txt_Dialogue.text += replaceText[i];
            yield return new WaitForSeconds(textDelayTime);
        }
        isNext = true;
}



































