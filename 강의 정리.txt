Part 1 기본 무대 및 UI 세팅
I. Edit -> Grid and Snap Setting을 이용하여 편하게 맵 만들기 (마우스를 통해 오브젝트를 한번 움직일 때마다 얼마나 움직일지를 설정할 수 있음)
II. UI 에서 Anchor Position을 설정할 때는 부모는 상단, 하단 처럼 전체적인 틀을 잡고 자식을 구석과 같이 디테일하게 설정하면 좋음 가운데에 있는 애들은 구지 설정 안해도 해상도 맞춰짐 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 1 크로스헤어 구현
1. [SerializeField] 는 private의 보호 수준은 유지하면서 인스펙터 창에 변수의 값을 보이게 함(할당도 가능)

2. 크로스헤어가 마우스 따라가게하기
I. 크로스 헤어의 포지션 값 
크로스헤어 UI는 Canvas의 자식 오브젝트이므로 원하는 좌표 값을 얻거나 할당하기 위해서는 부모 객처를 기준으로 상대적으로 얼마나 떨어져 있는지를 나타내는 localposition을 사용해야함

이때 Input.mouseposition 값을 크로스헤어의 포지션값에 그대로 적용했을 때 Input.mouseposition값은 화면 왼쪽 아래를 기준으로 0, 0을 가지기 때문에 마우스를 왼쪽 아래 구석에 가져가면 크로스헤어가 가운대로 오는 기적을 감상할 수 있기 때문에 x, y축에 스크린의 넓이와 높이의 반만큼 빼줘야함 그러면 왼쪽 아래 구석에 마우스를 놀 때 크로스 헤어의 포지션 값에 0, 0에서 화면 크기의 넓이와 높이의 반만큼 뺸 값이 대입되기 때문에 마우스와 똑같이 위치함

II. Screen : 디스플레이 정보에 접근하는데 사용하며 지원되는 해상도 목록을 가져오거나 변환하는데 사용됨
Screen.width : 해상도를 기준으로 화면의 넓이를 가져오며 단위는 픽셀을 사용(height는 높이) 

III. 주의사항
스크린의 크기는 해상도를 기준으로 가져오고 크로스헤어는 UI이므로 Canvas Sclaer의 Reference Resolution 값을 기준으로 위치하기 때문에 Reference Resolution의 값과 해상도 값을 일치시켜야함
만약 해상도를 Reference Resolution 값보다 크게 하면 스크린 값이 Canvas보다 크게 설정되어 크로스헤어의 포지션이 마우스 위치와 달라짐


3. 크로스헤어가 화면 밖으로 나가지 않게 하기
필요성 : Input.mouseposition는 마우스 포인터가 화면 밖에 있어도 위치를 보고하기 때문에 크로스헤어가 화면밖으로 나가 보이지 않을 수 있어 크로스헤어의 위치에 제한을 두어 화면 밖으로 나가지 않게 함

I. Mathf.Clamp()함수 
Mathf.Clamp(float value, float min, float max) : 기본적으로 value의 값을 반환하지만 value가 min보다 작으면 min을 max보다 크면 max값을 반환함 즉 기본적으로 vlaue를 반환하되 원하는 범위만큼 제한을 둔 값을 반환할 수 있음 value의 값에는 영향을 주지 않고 오직 반환값만 제한됨 

II. 마우스 포지션 값과 스크린 크기 값에 기반해 먼저 크로스헤어의 x, y 변숫값을 구한 후 그 변수에 이 함수를 통해 스크린의 크기만큼 제한한 값을 대입해 크로스헤어가 화면 밖으로 나가는 것을 방지함 

private float cursorMargin = 30; // 마진을 다 크로스헤어의 모든 부분이 화면에 보이게 하기 위한 여백값
// 크로스 헤어의 좌표값 구함
float corsshair_X = Input.mousePosition.x - Screen.width / 2;
float corsshair_Y = Input.mousePosition.y - Screen.height / 2;

// corsshair가 화면 밖으로 나가는거 방지하기 위해 스크린 크기만큼 제한한 값을 다시 할당
corsshair_X = Mathf.Clamp(corsshair_X, -Screen.width / 2 + cursorMargin, Screen.width / 2 - cursorMargin);
corsshair_Y = Mathf.Clamp(corsshair_Y, -Screen.height / 2 + cursorMargin, Screen.height / 2 - cursorMargin);
tf_Corsshair.localPosition = new Vector2(corsshair_X, corsshair_Y);

4. RectTranform
RectTranform을 사용할 경우 크로스헤어가 마우스를 그래도 따라가지만 여전히 좌측 하단이 0, 0이기 때문에 Screen의 크기를 이용해 크로스헤어의 범위에 제한을 두는 데에 문제가 생김

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Part 2 - 2 뷰 회전(크로스 헤어)
1. 크로스헤어가 끝부분에 있으면 그쪽 방향으로 회전하기
I. Part 2 - 1에서 구현한 크로스 헤어의 위치값이 스크린의 절반보다 크거나 작으면 작동하는  조건문 제작
if( corsshair_X > half_ScreenWidth - 80 || corsshair_X > -half_ScreenWidth + 80 )

II. 삼항 연산자를 통해 x좌표의 부호에 따라 회전값 변수에 회전 속도 변수를 더하거나 뺌
currentCameraAngle_Y += ( corsshair_X > 0 ) ? rotateSpeed : -rotateSpeed; 

III. 연산이 이뤄진 회전값 변수에 Mathf.Clamp() 함수를 이용하여 회전값에 제한을 둔 후 카메라 회전값에 대입함
currentCameraAngle_Y = Mathf.Clamp(currentCameraAngle_Y, -look_X_Limit, look_X_Limit);
같은 방법으로 currentCameraAngle_X를 구한 후 대입( 이때 x축 회전값의 방향은 더하면 내려가고 빼면 올라가기 때문에 삼항연산자 부호를 반대로 해야함)
th_Camera.rotation = Quaternion.Euler(new Vector3(currentCameraAngle_X, currentCameraAngle_Y, 0));



























